<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.rustc.io</id>
    <title>HelloWorld</title>
    <updated>2020-02-11T15:19:07.658Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.rustc.io"/>
    <link rel="self" href="https://www.rustc.io/atom.xml"/>
    <subtitle>尽走歪路</subtitle>
    <logo>https://www.rustc.io/images/avatar.png</logo>
    <icon>https://www.rustc.io/favicon.ico</icon>
    <rights>All rights reserved 2020, HelloWorld</rights>
    <entry>
        <title type="html"><![CDATA[2020 FLAG]]></title>
        <id>https://www.rustc.io/post/2020-flag</id>
        <link href="https://www.rustc.io/post/2020-flag">
        </link>
        <updated>2020-02-11T15:16:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="二月-三月">二月-三月</h1>
<p><a href="https://www.bilibili.com/video/av48922578?from=search&amp;seid=1375370299303546615">【计算科学】计算科学与编程导论-麻省理工</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入浅出Rust Future - Part 5]]></title>
        <id>https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part-5</id>
        <link href="https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part-5">
        </link>
        <updated>2020-02-08T18:38:44.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-5---streams-5i8">原文:Rust futures: an uneducated, short and hopefully not boring tutorial - Part 5 - Streams</a></p>
<h1 id="intro">Intro</h1>
<p>在上篇文章中我们学习了如何实现一个高效率的<code>Future</code>(尽量不阻塞, 只有在需要时才会<code>Unpark</code>我们的<code>Task</code>).  今天继续扩展我们的<code>Future</code>: 实现一个<code>Stream Trait</code>.<br>
<code>Stream</code>跟<code>Iterators</code>看起来很像: 他们随着时间的推移产生多个相同类型的输出, 与<code>Iterators</code>唯一的区别就是消费的方式不同. 让我们一起尝试使用<code>Reactor</code>来处理<code>Streams</code>吧.</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-5---streams-5i8">原文:Rust futures: an uneducated, short and hopefully not boring tutorial - Part 5 - Streams</a></p>
<h1 id="intro">Intro</h1>
<p>在上篇文章中我们学习了如何实现一个高效率的<code>Future</code>(尽量不阻塞, 只有在需要时才会<code>Unpark</code>我们的<code>Task</code>).  今天继续扩展我们的<code>Future</code>: 实现一个<code>Stream Trait</code>.<br>
<code>Stream</code>跟<code>Iterators</code>看起来很像: 他们随着时间的推移产生多个相同类型的输出, 与<code>Iterators</code>唯一的区别就是消费的方式不同. 让我们一起尝试使用<code>Reactor</code>来处理<code>Streams</code>吧.</p>
<!-- more -->
<h2 id="foreach-combinator">ForEach combinator</h2>
<p>我们使用一个名为<code>for_each</code>的组合器, 来代替我们手动迭代消费<code>Stream</code>. 查询文档不难发现<code>future::stream</code>实现了<code>ForEach</code>, 所以我们不仅可以迭代, 也可以把<code>stream</code>放入<code>Reactor</code>, 把它作为<code>Future Chain</code>的一部分. 这看起来简直太酷了.现在让我们一步一步来实现一个简单的<code>Stream</code>.</p>
<h2 id="impl-stream">impl Stream</h2>
<p><code>Stream Trait</code> 与 <code>Future Trait</code>很像:</p>
<pre><code>pub trait Future {
    type Item;
    type Error;
    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;

    // &lt;-- CUT --&gt;
}

pub trait Stream {
    type Item;
    type Error;
    fn poll(&amp;mut self) -&gt; Poll&lt;Option&lt;Self::Item&gt;, Self::Error&gt;;

    // &lt;-- CUT --&gt;
}
</code></pre>
<p>这两个<code>Trait</code>都有很多的函数, 由于这些函数都有默认值, 因此如果你不需要它, 就无需实现他们. 在本篇文章里我们只关注<code>poll</code>这个方法.</p>
<pre><code>    // Future
    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;

    // Stream
    fn poll(&amp;mut self) -&gt; Poll&lt;Option&lt;Self::Item&gt;, Self::Error&gt;;
</code></pre>
<p>对比下<code>Future</code>与<code>Stream</code>两者<code>poll</code>函数的区别:</p>
<table>
<thead>
<tr>
<th>Situation</th>
<th>Future</th>
<th>Stream</th>
</tr>
</thead>
<tbody>
<tr>
<td>Item to return ready</td>
<td>Ok(Async::Ready(t))</td>
<td>Ok(Async::Ready(Some(t)))</td>
</tr>
<tr>
<td>Item to return not ready</td>
<td>Ok(Async::NotReady)</td>
<td>Ok(Async::NotReady)</td>
</tr>
<tr>
<td>No more items to return</td>
<td>N.A.</td>
<td>Ok(Async::Ready(None))</td>
</tr>
<tr>
<td>Error</td>
<td>Err(e)</td>
<td>Err(e)</td>
</tr>
</tbody>
</table>
<h2 id="simple-stream">Simple stream</h2>
<p>让我们一起实现一个简单的<code>stream</code>:</p>
<pre><code>struct MyStream {
    current: u32,
    max: u32,
}

impl MyStream {
    pub fn new(max: u32) -&gt; MyStream {
        MyStream {
            current: 0,
            max: max,
        }
    }
}

impl Stream for MyStream {
    type Item = u32;
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Option&lt;Self::Item&gt;, Self::Error&gt; {
        match self.current {
            ref mut x if *x &lt; self.max =&gt; {
                *x = *x + 1;
                Ok(Async::Ready(Some(*x)))
            }
            _ =&gt; Ok(Async::Ready(None)),
        }
    }
}
</code></pre>
<p>我们重点关注下<code>poll</code>函数, 形参传递了一个可变引用, 所以我们可以改变<code>MyStream</code>内部的值. 这段代码理解起来很容易:</p>
<blockquote>
<p>检查<code>MyStream.current</code>是否大于 <code>MyStream.max</code> 如果大于: 返回<code>Ok(Async::Ready(None))</code>, 否则<code>MyStream.current</code>自增<code>1</code>并且返回当前的值.</p>
</blockquote>
<h2 id="consume-a-stream">Consume a stream</h2>
<pre><code>let mut reactor = Core::new().unwrap();
let my_stream = MyStream::new(5);

let fut = my_stream.for_each(|num| {
    println!(&quot;num === {}&quot;, num);
    ok(())
});
</code></pre>
<p>注意<code>ok(())</code>, 这段代码意味着我们返回的是个<code>Future</code>, 所以我们不仅可以使用<code>Reactor</code>执行<code>fut</code>, 也可以跟别的<code>Future</code>, 组合成<code>Future Chain</code>.</p>
<h2 id="spawn-futures-during-the-event-loop">Spawn futures during the event loop</h2>
<p>我们在处理<code>Stream</code>时, 有时候想创建(spawn:派生)新的<code>Future</code>, 这样做理由有很多, 比如不想阻塞当前的<code>Future Task</code>, <code>Rust</code> 是允许我们使用<code>Reactor</code>的<code>execute</code>函数将创建的<code>Future</code>加入现有的事件循环中的. 然而这有一个陷阱: <code>execute</code> 返回的是<code>Result&lt;(), ExecuteError&lt;f&gt;&gt;</code>, 可以看出这个函数正常返回时,没有任何的值.</p>
<pre><code>
impl Stream for MyStream {
    type Item = u32;
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Option&lt;Self::Item&gt;, Self::Error&gt; {
        use futures::future::Executor;

        match self.current {
            ref mut x if *x &lt; self.max =&gt; {
                *x = *x + 1;

                self.core_handle.execute(WaitInAnotherThread::new(
                    Duration::seconds(2),
                    format!(&quot;WAIT {:?}&quot;, x),
                ));
                Ok(Async::Ready(Some(*x)))
            }
            _ =&gt; Ok(Async::Ready(None)),
        }
    }
}

</code></pre>
<p>这里需要关注的是<code>execute</code>这段代码, 它产生一个新的<code>Future</code>(等待两秒, 然后打印x), 不过请记住, 这个<code>future</code>将不会返回任何值(除了<code>Error</code>), 所以我们当且仅当把他是一个<code>Daemon-like</code>线程.</p>
<p>测试Code:</p>
<pre><code>
fn main() {
    let mut reactor = Core::new().unwrap();

    // create a Stream returning 5 items
    // Each item will spawn an &quot;inner&quot; future
    // into the same reactor loop
    let my_stream = MyStream::new(5, reactor.handle());

    // we use for_each to consume
    // the stream
    let fut = my_stream.for_each(|num| {
        println!(&quot;num === {:?}&quot;, num);
        ok(())
    });

    // this is a manual future. it's the same as the
    // future spawned into our stream
    let wait = WaitInAnotherThread::new(Duration::seconds(3), &quot;Manual3&quot;.to_owned());

    // we join the futures to let them run concurrently
    let future_joined = fut.map_err(|err| {}).join(wait);

    // let's run the future
    let ret = reactor.run(future_joined).unwrap();
    println!(&quot;ret == {:?}&quot;, ret);
}

</code></pre>
<p>上端代码我们展示了如何连接<code>Stream</code>和<code>Future</code>. 现在让我尝试跑一下我们的代码:</p>
<pre><code>
num === 1
num === 2
num === 3
num === 4
num === 5
&quot;Manual3&quot; starting the secondary thread!
&quot;Manual3&quot; not ready yet! parking the task.
&quot;WAIT 1&quot; starting the secondary thread!
&quot;WAIT 1&quot; not ready yet! parking the task.
&quot;WAIT 2&quot; starting the secondary thread!
&quot;WAIT 2&quot; not ready yet! parking the task.
&quot;WAIT 3&quot; starting the secondary thread!
&quot;WAIT 3&quot; not ready yet! parking the task.
&quot;WAIT 4&quot; starting the secondary thread!
&quot;WAIT 4&quot; not ready yet! parking the task.
&quot;WAIT 5&quot; starting the secondary thread!
&quot;WAIT 5&quot; not ready yet! parking the task.
&quot;WAIT 1&quot; the time has come == 2017-12-06T10:23:30.853796527Z!
&quot;WAIT 1&quot; ready! the task will complete.
&quot;WAIT 2&quot; the time has come == 2017-12-06T10:23:30.853831227Z!
&quot;WAIT 2&quot; ready! the task will complete.
&quot;WAIT 3&quot; the time has come == 2017-12-06T10:23:30.853842927Z!
&quot;WAIT 3&quot; ready! the task will complete.
&quot;WAIT 5&quot; the time has come == 2017-12-06T10:23:30.853856927Z!
&quot;WAIT 5&quot; ready! the task will complete.
&quot;WAIT 4&quot; the time has come == 2017-12-06T10:23:30.853850427Z!
&quot;WAIT 4&quot; ready! the task will complete.
&quot;Manual3&quot; the time has come == 2017-12-06T10:23:31.853775627Z!
&quot;Manual3&quot; ready! the task will complete.
ret == ((), ())

</code></pre>
<p>这个结果不是唯一的, 你和我的输出也许有所不同, 如果我们没有派生等待3s的<code>Future</code>, 结果是否就会有所不同?</p>
<pre><code>
fn main() {
    let mut reactor = Core::new().unwrap();

    // create a Stream returning 5 items
    // Each item will spawn an &quot;inner&quot; future
    // into the same reactor loop
    let my_stream = MyStream::new(5, reactor.handle());

    // we use for_each to consume
    // the stream
    let fut = my_stream.for_each(|num| {
        println!(&quot;num === {:?}&quot;, num);
        ok(())
    });

    // let's run the future
    let ret = reactor.run(fut).unwrap();
    println!(&quot;ret == {:?}&quot;, ret);
}

</code></pre>
<p>我们会注意到这段代码几乎会立即返回下面的值:</p>
<pre><code>
num === 1
num === 2
num === 3
num === 4
num === 5
ret == ()

</code></pre>
<p><code>poll</code> 函数里派生出的<code>Future</code>没有机会运行.</p>
<h2 id="next-steps">Next steps</h2>
<p>下一篇我们将会使用<code>await!()</code>来精简我们的Future`.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入浅出Rust Future - Part4 -  A real future from scratch]]></title>
        <id>https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part4-a-real-future-from-scratch</id>
        <link href="https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part4-a-real-future-from-scratch">
        </link>
        <updated>2020-02-08T18:36:50.000Z</updated>
        <summary type="html"><![CDATA[<p>译自<a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-4---a-real-future-from-scratch-734">Rust futures: an uneducated, short and hopefully not boring tutorial - Part 4 - A &quot;real&quot; future from scratch</a></p>
<h1 id="intro">Intro</h1>
<p>上三篇文章我们阐述如何处理<code>Future</code>的基础知识， 我们现在能组织多个<code>Future</code>成为一个<code>Future chain</code>, 执行他们,甚至创建他们.但是到现在我们的<code>Future</code>还没有贴近我们日常的使用场景。(But, so far, our futures are not really delegating the execution to another thing.)<br>
在Part-3中我们用了粗暴的方法来<code>Unpark Future</code>。虽然解决了问题，并且使<code>Reactor</code>变得相对高效，但是这不是最佳实践。今天就让我们换种更好的方式去实现<code>Future</code>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>译自<a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-4---a-real-future-from-scratch-734">Rust futures: an uneducated, short and hopefully not boring tutorial - Part 4 - A &quot;real&quot; future from scratch</a></p>
<h1 id="intro">Intro</h1>
<p>上三篇文章我们阐述如何处理<code>Future</code>的基础知识， 我们现在能组织多个<code>Future</code>成为一个<code>Future chain</code>, 执行他们,甚至创建他们.但是到现在我们的<code>Future</code>还没有贴近我们日常的使用场景。(But, so far, our futures are not really delegating the execution to another thing.)<br>
在Part-3中我们用了粗暴的方法来<code>Unpark Future</code>。虽然解决了问题，并且使<code>Reactor</code>变得相对高效，但是这不是最佳实践。今天就让我们换种更好的方式去实现<code>Future</code>。</p>
<!-- more -->
<h2 id="a-timer-future">A timer future</h2>
<p>我们可以创建一个最简单的<code>Timer Future</code>(就像我们在Part-3章节所做的那样). 但这一次，我们不会立即<code>Unpark Future Task</code>, 而是一直<code>Parked</code>， 直到这个<code>Future</code>准备完为止. 我们该怎样实现？ 最简单的方式就是再委派一个线程。这个线程将等待一段时间， 然后<code>Unpark</code>我们的<code>Future Task</code>.</p>
<p>这就像在模拟一个<code>AsyncIO</code>的使用场景。当我们异步做的一些事情已经完成我们会收到与之相应的通知。为了简单起见，我们认为<code>Reactor</code>是单线程的，在等待通知的时候可以做其他的事情。</p>
<h2 id="timer-revised">Timer revised</h2>
<p>我们的结构体非常简单.他包含结束日期和任务是否在运行。</p>
<pre><code>pub struct WaitInAnotherThread {
    end_time: DateTime&lt;Utc&gt;,
    running: bool,
}

impl WaitInAnotherThread {
    pub fn new(how_long: Duration) -&gt; WaitInAnotherThread {
        WaitInAnotherThread {
            end_time: Utc::now() + how_long,
            running: false,
        }
    }
}
</code></pre>
<p><code>DateTime</code>类型和<code>Duration</code>持续时间来自<code>chronos crate</code>.</p>
<h2 id="spin-wait">Spin wait</h2>
<p>实现等待时间的函数:</p>
<pre><code>pub fn wait_spin(&amp;self) {
    while Utc::now() &lt; self.end_time {}
    println!(&quot;the time has come == {:?}!&quot;, self.end_time);
}

fn main() {
    let wiat = WaitInAnotherThread::new(Duration::seconds(30));
    println!(&quot;wait spin started&quot;);
    wiat.wait_spin();
    println!(&quot;wait spin completed&quot;);
}
</code></pre>
<p>在这种情况下，我们基本上会根据到期时间检查当前时间。 这很有效，而且非常精确。 这种方法的缺点是我们浪费了大量的CPU周期。 在我的电脑上, CPU一个核心完全被占用，这和我们<code>Part-3</code>遇到的情况一致。</p>
<blockquote>
<p>Spin wait这种方式只适用于等待时间非常短的场景, 或者你没有别的选择的情况下使用它。</p>
</blockquote>
<h2 id="sleep-wait">Sleep wait</h2>
<p>系统通常会允许你的线程<code>Park</code>一段特定的时间.这通常被称为线程睡眠。睡眠线程X秒，换据换的意思是: 告诉系统X秒内，不需要调度我。这样的好处是，CPU可以在这段时间内干别的事情。在<code>Rust</code>中我们使用<code>std::thread::sleep()</code>.</p>
<pre><code>pub fn wait_blocking(&amp;self) {
    while Utc::now() &lt; self.end_time {
        let delta_sec = self.end_time.timestamp() - Utc::now().timestamp();
        if delta_sec &gt; 0 {
            thread::sleep(::std::time::Duration::from_secs(delta_sec as u64));
        }
    }
    println!(&quot;the time has come == {:?}!&quot;, self.end_time);
}

let wiat = WaitInAnotherThread::new(Duration::seconds(30));
println!(&quot;wait blocking started&quot;);
wiat.wait_blocking();
println!(&quot;wait blocking completed&quot;);
</code></pre>
<p>尝试运行我们的代码会发现, 改进过的代码再也不会完全占用一个CPU核心了。改进过的代码比我们该开始写的性能好多了，但是这就是<code>Future</code>了吗？</p>
<h2 id="future">Future</h2>
<p>当然不是，我们还没有实现<code>Future Trait</code>, 所以，我们现在实现它。</p>
<pre><code>impl Future for WaitInAnotherThread {
    type Item = ();
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        while Utc::now() &lt; self.end_time {
            let delta_sec = self.end_time.timestamp() - Utc::now().timestamp();
            if delta_sec &gt; 0 {
                thread::sleep(::std::time::Duration::from_secs(delta_sec as u64));
            }
        }
        println!(&quot;the time has come == {:?}!&quot;, self.end_time);
        Ok(Async::Ready(())
}
</code></pre>
<p>emmm，这块代码我们是不是以前见过， 跟上篇我们写的一个很像，它会阻塞<code>Reactor</code>，这样做实在是太糟糕了。</p>
<blockquote>
<p><code>Future</code> 应该尽可能的不要阻塞。</p>
</blockquote>
<p>一个<code>Reactor</code>的最佳实践应该至少包含下面几条：</p>
<ul>
<li>当主<code>Task</code>需要等待别的<code>Task</code>时，应该停止它。</li>
<li>不要阻塞当前线程。</li>
<li>任务完成时向<code>Reactor</code>发送信号。</li>
</ul>
<p>我们要做的是创建另一个睡眠线程. 睡眠的线程是不会占用CPU资源。所以在另一个线程里<code>Reactor</code>还像往常那样，高效的工作着。当这个<code>Sleep Thread</code>醒来后, 它会<code>Unpark</code>这个任务, 并且通知<code>Reactor</code>。</p>
<p>让我们一步一步完善我们的想法:</p>
<pre><code>impl Future for WaitInAnotherThread {
    type Item = ();
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        if Utc::now() &lt; self.end_time {
            println!(&quot;not ready yet! parking the task.&quot;);

            if !self.running {
                println!(&quot;side thread not running! starting now!&quot;);
                self.run(task::current());
                self.running = true;
            }

            Ok(Async::NotReady)
        } else {
            println!(&quot;ready! the task will complete.&quot;);
            Ok(Async::Ready(()))
        }
    }
}
</code></pre>
<p>我们只需要创建一个并行线程, 所以我们需要有个字段来判断(<code>WaitInAnotherThread.runing</code>)，当前需不需要创建这个线程。这里需要注意的是当<code>Future</code>被轮询之前，这些代码是不会被执行的。当然我们还会检测当前时间是否大于过期时间，如果大于，也不会产生另外一个线程。</p>
<p>如果<code>end_time</code>大于当前的时间并且另一个线程没有被创建，程序就会立即创建一个新的线程。然后程序会返回<code>Ok(Async::NotReady())</code>, 与我们<code>Part-3</code>中所做的相反，我们不会在这里<code>Unpark Task</code>. 这是另一个线程应该做的事情。在别的实现中，例如IO，唤醒我们的主线程的应该是操作系统。</p>
<pre><code>fn run(&amp;mut self, task: task::Task) {
    let lend = self.end_time;

    thread::spawn(move || {
        while Utc::now() &lt; lend {
            let delta_sec = lend.timestamp() - Utc::now().timestamp();
            if delta_sec &gt; 0 {
                thread::sleep(::std::time::Duration::from_secs(delta_sec as u64));
            }
            task.notify();
        }
        println!(&quot;the time has come == {:?}!&quot;, lend);
    });
}
</code></pre>
<p>这里有两件事情需要注意下.</p>
<ul>
<li>
<p>我们将<code>Task</code>引用传递给，另一个并行的线程。这很重要，因为我们不能在单独的线程里使用<code>task::current</code>.</p>
</li>
<li>
<p>我们不能将self移动到闭包中，所以我们需要转移所有权至<code>lend</code>变量.为啥这样做？</p>
</li>
</ul>
<blockquote>
<p>Rust中的线程需要实现具有<code>'static</code>生命周期的<code>Send Trait</code>。</p>
</blockquote>
<p><code>task</code>自身实现了上述的要求所以可以引用传递。但是我们的结构体没有实现，所以这也是为什么要移动<code>end_time</code>的所有权。这就意味着当线程被创建后你不能更改<code>end_time</code>.</p>
<p>让我们尝试运行下:</p>
<pre><code>fn main() {
    let mut reactor = Core::new().unwrap();

    let wiat = WaitInAnotherThread::new(Duration::seconds(3));
    println!(&quot;wait future started&quot;);
    let ret = reactor.run(wiat).unwrap();
    println!(&quot;wait future completed. ret == {:?}&quot;, ret);
}
</code></pre>
<p>运行结果：</p>
<pre><code>Finished dev [unoptimized + debuginfo] target(s) in 0.96 secs
Running `target/debug/tst_fut_complete`
wait future started
not ready yet! parking the task.
side thread not running! starting now!
the time has come == 2017-11-21T12:55:23.397862771Z!
ready! the task will complete.
wait future completed. ret == ()
</code></pre>
<p>让我们总结下流程：</p>
<ul>
<li>
<p>我们让<code>Reactor</code>执行我们的<code>Future</code>.</p>
</li>
<li>
<p><code>Future</code>发现<code>end_time</code>大于当前时间：</p>
<ol>
<li><code>Park Task</code></li>
<li>开启另一个线程</li>
</ol>
</li>
<li>
<p>副线程在一段时间后被唤醒:</p>
<ol>
<li>告诉<code>Reactor</code>我们的<code>Task</code>可以<code>Unpark</code>了。</li>
<li>销毁自身</li>
</ol>
</li>
<li>
<p><code>Reactor</code>唤醒被<code>Park</code>的<code>Task</code></p>
</li>
<li>
<p><code>Future(Task)</code>完成了自身的任务：</p>
<ol>
<li>通知<code>Reactor</code></li>
<li>返回相应的结果</li>
</ol>
</li>
<li>
<p>reactor将任<code>Task</code>的输出值返回给run函数的调用者。</p>
</li>
</ul>
<h2 id="code">Code</h2>
<pre><code>extern crate chrono;
extern crate futures;

extern crate tokio_core;

use chrono::prelude::*;
use chrono::*;
use futures::prelude::*;
use futures::*;
use std::error::Error;
use std::thread::{sleep, spawn};
use tokio_core::reactor::Core;

pub struct WaitInAnotherThread {
    end_time: DateTime&lt;Utc&gt;,
    running: bool,
}

impl WaitInAnotherThread {
    pub fn new(how_long: Duration) -&gt; WaitInAnotherThread {
        WaitInAnotherThread {
            end_time: Utc::now() + how_long,
            running: false,
        }
    }

    fn run(&amp;mut self, task: task::Task) {
        let lend = self.end_time;

        spawn(move || {
            while Utc::now() &lt; lend {
                let delta_sec = lend.timestamp() - Utc::now().timestamp();
                if delta_sec &gt; 0 {
                    sleep(::std::time::Duration::from_secs(delta_sec as u64));
                }
                task.notify();
            }
            println!(&quot;the time has come == {:?}!&quot;, lend);
        });
    }
}

impl Future for WaitInAnotherThread {
    type Item = ();
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        if Utc::now() &lt; self.end_time {
            println!(&quot;not ready yet! parking the task.&quot;);

            if !self.running {
                println!(&quot;side thread not running! starting now!&quot;);
                self.run(task::current());
                self.running = true;
            }

            Ok(Async::NotReady)
        } else {
            println!(&quot;ready! the task will complete.&quot;);
            Ok(Async::Ready(()))
        }
    }
}

fn main() {
    let mut reactor = Core::new().unwrap();

    let wiat = WaitInAnotherThread::new(Duration::seconds(3));
    println!(&quot;wait future started&quot;);
    let ret = reactor.run(wiat).unwrap();
    println!(&quot;wait future completed. ret == {:?}&quot;, ret);
}
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>到目前未知我们完整的实现了没有阻塞的<code>real life future</code>. 所以也没有浪费CPU资源。除了这个例子你还能想到与此相同的应用场景吗？<br>
尽管<code>RUST</code>早都有现成的<code>Crate</code>帮我们实现好了。但是了解其中的工作原理还是对我们有很大的帮助。</p>
<p>下一个主题将是Streams，目标是：创建一个不会阻塞<code>Reactor</code>的<code>Iterators</code>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入浅出Rust Future - Part3 - The Reactor]]></title>
        <id>https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part3-the-reactor</id>
        <link href="https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part3-the-reactor">
        </link>
        <updated>2020-02-08T18:34:40.000Z</updated>
        <summary type="html"><![CDATA[<p>译自<a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-3---the-reactor-433">Rust futures: an uneducated, short and hopefully not boring tutorial - Part 3 - The reactor</a></p>
<h1 id="intro">Intro</h1>
<p>在这篇文章中我们将会讨论和阐释<code>Reactor</code>是如何工作的.在上篇文章中我们，我们频繁的使用<code>Reactor</code>来执行我们的<code>Future</code>，但是并没有阐述它是如何工作的。现在是时候阐明它了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>译自<a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-3---the-reactor-433">Rust futures: an uneducated, short and hopefully not boring tutorial - Part 3 - The reactor</a></p>
<h1 id="intro">Intro</h1>
<p>在这篇文章中我们将会讨论和阐释<code>Reactor</code>是如何工作的.在上篇文章中我们，我们频繁的使用<code>Reactor</code>来执行我们的<code>Future</code>，但是并没有阐述它是如何工作的。现在是时候阐明它了。</p>
<!-- more -->
<h2 id="reactor-loop">Reactor? Loop?</h2>
<p>如果用一句话来描述<code>Reactor</code>，那应该是:</p>
<blockquote>
<p><code>Reactor</code>是一个环(<code>Loop</code>)</p>
</blockquote>
<p>举个栗子：<br>
你决定通过Email邀请你喜欢的女孩或者男孩(emmm, 这个栗子听起来很老套), 你怀着忐忑的心将这份邮件发送出去，心里焦急着等待着， 不停的一遍又一遍的检查你的邮箱是否有新的回复. 直到收到回复。<br>
<code>Rust's Reactor</code>就是这样， 你给他一个<code>future</code>, 他会不断的检查，直到这个<code>future</code>完成(或者返回错误). <code>Reactor</code>通过调用程序员实现的<code>Poll</code>函数，来检查<code>Future</code>是否已完成。你所要做的就是实现<code>future poll</code> 并且返回<code>Poll&lt;T, E&gt;</code>结构。但是 <code>Reactor</code>也不会无休止的对你的<code>future function</code>轮询。</p>
<h2 id="a-future-from-scratch">A future from scratch</h2>
<p>为了让我们能更容易理解<code>Reactor</code>知识，我们还是从零开始实现一个<code>Future</code>. 换句话说就是，我们将动手实现<code>Future Trait</code>.</p>
<pre><code>#[derive(Debug)]
struct WaitForIt {
    message: String,
    until: DateTime&lt;Utc&gt;,
    polls: u64,
}
</code></pre>
<p>我们的结构体字段也很简单:</p>
<ul>
<li>message： 自定义字符串消息体</li>
<li>polls: 轮循次数</li>
<li>util: 等待时间</li>
</ul>
<p>我们还会实现 <code>WaitFotIt</code>结构体的<code>new</code>方法.这个方法作用是初始化<code>WaitForIt</code></p>
<pre><code>impl WaitForIt {
    pub fn new(message: String, delay: Duration) -&gt; WaitForIt {
        WaitForIt {
            polls: 0,
            message: message,
            until: Utc::now() + delay,
        }
    }
}

impl Future for WaitForIt {
    type Item = String;
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        let now = Utc::now();
        if self.until &lt; now {
            Ok(Async::Ready(
                format!(&quot;{} after {} polls!&quot;, self.message, self.polls),
            ))
        } else {
            self.polls += 1;

            println!(&quot;not ready yet --&gt; {:?}&quot;, self);
            Ok(Async::NotReady)
        }
    }
}
</code></pre>
<p>让我们逐步解释</p>
<pre><code>    type Item = String;
    type Error = Box&lt;Error&gt;;
</code></pre>
<p>上面两行在<code>RUST</code>里被叫做<code>associated types</code>, 意思就是<code>Future</code>在将来完成时返回的值(或者错误).</p>
<pre><code>    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {}
</code></pre>
<p>定义轮询的方法。<code>Self::Item, Self::Error</code> 是我们定义的<code>associated types</code>站位符。在我们的例子中，该方法如下：</p>
<pre><code>fn poll（＆mut self） - &gt; Poll &lt;String，Box &lt;Error &gt;&gt;
</code></pre>
<p>现在看看我们的逻辑代码:</p>
<pre><code>let now = Utc::now();
if self.until &lt; now {
// 告诉reactor `Future` 已经完成了！
} else {
// 告诉 reactor `Future` 还没准备好，过会儿再来。
}
</code></pre>
<p>在<code>Rust</code>里我们该怎样告诉<code>Reactor</code>某个<code>Future</code>已经完成了？很简单使用枚举</p>
<pre><code>Ok(Async::NotReady(.......)) // 还没完成
Ok(Async::Ready(......)) // 完成了
</code></pre>
<p>让我们来实现上述的方法：</p>
<pre><code>impl Future for WaitForIt {
    type Item = String;
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        let now = Utc::now();
        if self.until &lt; now {
            Ok(Async::Ready(
                format!(&quot;{} after {} polls!&quot;, self.message, self.polls),
            ))
        } else {
            self.polls += 1;

            println!(&quot;not ready yet --&gt; {:?}&quot;, self);
            Ok(Async::NotReady)
        }
    }
}
</code></pre>
<p>为了让这段代码运行起来我们还需要：</p>
<pre><code>extern crate chrono;
extern crate futures;

extern crate tokio_core;

use futures::done;
use futures::prelude::*;
use futures::future::{err, ok};
use tokio_core::reactor::Core;
use std::error::Error;
use futures::prelude::*;
use futures::*;
use chrono::prelude::*;
use chrono::*;

fn main() {
    let mut reactor = Core::new().unwrap();

    let wfi_1 = WaitForIt::new(&quot;I'm done:&quot;.to_owned(), Duration::seconds(1));
    println!(&quot;wfi_1 == {:?}&quot;, wfi_1);

    let ret = reactor.run(wfi_1).unwrap();
    println!(&quot;ret == {:?}&quot;, ret);
}
</code></pre>
<p>运行!! 等待一秒我们将会看到结果：</p>
<pre><code>Running `target/debug/tst_fut_create`
wfi_1 == WaitForIt { message: &quot;I\'m done:&quot;, until: 2017-11-07T16:07:06.382232234Z, polls: 0 }
not ready yet --&gt; WaitForIt { message: &quot;I\'m done:&quot;, until: 2017-11-07T16:07:06.382232234Z, polls: 1 }
</code></pre>
<p>emmm~, 只运行一次就被卡住了, 但是没有额外的消耗<code>CPU</code>.但是为什么会这样？</p>
<blockquote>
<p>如果不明确告诉<code>Reactor</code>， <code>Reactor</code>是不会再次轮询停放(park)给它的<code>Future</code>.</p>
</blockquote>
<p>(- 译注： Park: 翻译成停放其实也挺好的，就像车场的停车位一样.)</p>
<p>在我们的例子里， <code>Reactor</code>会立即执行我们停放的<code>Future</code>方法， 当我们返回<code>Async::NotReady</code>, 它就会认为当前停放的<code>Future</code>还未完成。如果我们不主动去解除停放，<code>Reactor</code>永远也不会再次调用。</p>
<p>空闲中的<code>Reactor</code>是不会消耗CPU的。这样看起来<code>Reactor</code>效率还是很高的。<br>
在我们的电子邮件示例中，我们可以避免手动检查邮件并等待通知。 所以我们可以在此期间自由玩Doom。(emm～看来作者很喜欢这款游戏).</p>
<p>另一个更有意义的示例可能是从网络接收数据。 我们可以阻止我们的线程等待网络数据包，或者我们等待时可以做其他事情。 您可能想知道为什么这种方法比使用OS线程更好？</p>
<h2 id="unparking">Unparking</h2>
<p>我们该如何纠正我们例子？我们需要以某种方式取消我们的<code>Future</code>。 理想情况下，我们应该有一些外部事件来取消我们的<code>Future</code>（例如按键或网络数据包),但是对于我们的示例，我们将使用这个简单的行手动取消停放</p>
<pre><code>futures::task::current().notify();
</code></pre>
<p>像这样:</p>
<pre><code>impl Future for WaitForIt {
    type Item = String;
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        let now = Utc::now();
        if self.until &lt; now {
            Ok(Async::Ready(
                format!(&quot;{} after {} polls!&quot;, self.message, self.polls),
            ))
        } else {
            self.polls += 1;

            println!(&quot;not ready yet --&gt; {:?}&quot;, self);
            futures::task::current().notify();
            Ok(Async::NotReady)
        }
    }
}
</code></pre>
<p>现在代码完成了。 请注意，在我的情况下，该函数已被调用超过50k次， CPU占用也很高！<br>
这是严重的浪费，也清楚地说明你为什么需要在某个合理的时间点去<code>Unpark Future</code>.( That's a waste of resources and clearly demonstrates why you should unpark your future only when something happened. )</p>
<p>另请注意循环如何仅消耗单个线程。 这是设计和效率的来源之一。 当然，如果需要，您可以使用更多线程。</p>
<h2 id="joining">Joining</h2>
<p><code>Reactor</code>可以同时运行多个<code>Future</code>，这也是他为什么如此有效率的原因. 那么我们该如何充分利用单线程: 当一个<code>Future</code>被停放的时候, 另一个可以继续工作。</p>
<p>对于这个例子，我们将重用我们的WaitForIt结构。 我们只是同时调用两次。 我们开始创建两个<code>Future</code>的实例：</p>
<pre><code>let wfi_1 = WaitForIt::new(&quot;I'm done:&quot;.to_owned(), Duration::seconds(1));
println!(&quot;wfi_1 == {:?}&quot;, wfi_1);
let wfi_2 = WaitForIt::new(&quot;I'm done too:&quot;.to_owned(), Duration::seconds(1));
println!(&quot;wfi_2 == {:?}&quot;, wfi_2);
</code></pre>
<p>现在我们来调用<code>futures::future::join_all</code>， 他需要一个<code>vec![]</code>迭代器， 并且返回枚举过的<code>Future</code></p>
<pre><code>let v = vec![wfi_1, wfi_2];
let sel = join_all(v);
</code></pre>
<p>我们重新实现的代码像这样:</p>
<pre><code>fn main() {
    let mut reactor = Core::new().unwrap();

    let wfi_1 = WaitForIt::new(&quot;I'm done:&quot;.to_owned(), Duration::seconds(1));
    println!(&quot;wfi_1 == {:?}&quot;, wfi_1);
    let wfi_2 = WaitForIt::new(&quot;I'm done too:&quot;.to_owned(), Duration::seconds(1));
    println!(&quot;wfi_2 == {:?}&quot;, wfi_2);

    let v = vec![wfi_1, wfi_2];

    let sel = join_all(v);

    let ret = reactor.run(sel).unwrap();
    println!(&quot;ret == {:?}&quot;, ret);
}
</code></pre>
<p>这里的关键点是两个请求是交错的：第一个<code>Future</code>被调用，然后是第二个，然后是第一个，依此类推，直到两个完成。 如上图所示，第一个<code>Future</code>在第二个之前完成。 第二个在完成之前被调用两次。</p>
<h2 id="select">Select</h2>
<p><code>Future</code>的特性还有很多功能。 这里值得探讨的另一件事是select函数。 select函数运行两个（或者在select_all的情况下更多）<code>Future</code>，并返回第一个完成。 这对于实现超时很有用。 我们的例子可以简单：</p>
<pre><code>fn main() {
    let mut reactor = Core::new().unwrap();

    let wfi_1 = WaitForIt::new(&quot;I'm done:&quot;.to_owned(), Duration::seconds(1));
    println!(&quot;wfi_1 == {:?}&quot;, wfi_1);
    let wfi_2 = WaitForIt::new(&quot;I'm done too:&quot;.to_owned(), Duration::seconds(2));
    println!(&quot;wfi_2 == {:?}&quot;, wfi_2);

    let v = vec![wfi_1, wfi_2];

    let sel = select_all(v);

    let ret = reactor.run(sel).unwrap();
    println!(&quot;ret == {:?}&quot;, ret);
}
</code></pre>
<h2 id="closing-remarks">Closing remarks</h2>
<p>下篇将会创建一个更<code>Real</code>的<code>Future</code>.</p>
<h2 id="可运行的代码">可运行的代码</h2>
<pre><code>extern crate chrono;
extern crate futures;

extern crate tokio_core;

use futures::done;
use futures::prelude::*;
use futures::future::{err, ok};
use tokio_core::reactor::Core;
use std::error::Error;
use futures::prelude::*;
use futures::*;
use chrono::prelude::*;
use chrono::*;
use futures::future::join_all;
#[derive(Debug)]
struct WaitForIt {
    message: String,
    until: DateTime&lt;Utc&gt;,
    polls: u64,
}

impl WaitForIt {
    pub fn new(message: String, delay: Duration) -&gt; WaitForIt {
        WaitForIt {
            polls: 0,
            message: message,
            until: Utc::now() + delay,
        }
    }
}

impl Future for WaitForIt {
    type Item = String;
    type Error = Box&lt;Error&gt;;

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        let now = Utc::now();
        if self.until &lt; now {
            Ok(Async::Ready(
                format!(&quot;{} after {} polls!&quot;, self.message, self.polls),
            ))
        } else {
            self.polls += 1;

            println!(&quot;not ready yet --&gt; {:?}&quot;, self);
            futures::task::current().notify();
            Ok(Async::NotReady)
        }
    }
}

fn main() {
    let mut reactor = Core::new().unwrap();

    let wfi_1 = WaitForIt::new(&quot;I'm done:&quot;.to_owned(), Duration::seconds(1));
    println!(&quot;wfi_1 == {:?}&quot;, wfi_1);
    let wfi_2 = WaitForIt::new(&quot;I'm done too:&quot;.to_owned(), Duration::seconds(1));
    println!(&quot;wfi_2 == {:?}&quot;, wfi_2);

    let v = vec![wfi_1, wfi_2];

    let sel = join_all(v);

    let ret = reactor.run(sel).unwrap();
    println!(&quot;ret == {:?}&quot;, ret);
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入浅出Rust Future - Part 2]]></title>
        <id>https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part-2</id>
        <link href="https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part-2">
        </link>
        <updated>2020-02-08T18:32:17.000Z</updated>
        <summary type="html"><![CDATA[<p>译自<a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-2-8dd">Rust futures: an uneducated, short and hopefully not boring tutorial - Part 2</a></p>
<h1 id="intro">Intro</h1>
<p>在这个系列的第一篇文章我们了解了如何使用<code>Rust Future</code>.但是只有我们彻底的了解<code>Future</code>并且操作得当才能发挥它真正的作用。这个系列的第二篇文章，我们将介绍如何避免<code>Future</code>里常见的陷阱。</p>
]]></summary>
        <content type="html"><![CDATA[<p>译自<a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-2-8dd">Rust futures: an uneducated, short and hopefully not boring tutorial - Part 2</a></p>
<h1 id="intro">Intro</h1>
<p>在这个系列的第一篇文章我们了解了如何使用<code>Rust Future</code>.但是只有我们彻底的了解<code>Future</code>并且操作得当才能发挥它真正的作用。这个系列的第二篇文章，我们将介绍如何避免<code>Future</code>里常见的陷阱。</p>
<!-- more -->
<h2 id="error-troubles">Error troubles</h2>
<p>我们将<code>Future</code>组织成一个<code>链</code>很简单，只要通过<code>Rust Future</code>提供的<code>and_then</code>函数就可以了。但是在上一篇文章中我们使用了<code>Box&lt;Error&gt; trait</code>作为错误类型，绕过了编译器的检查。为什么我们没有使用更为详细的错误类型？原因很简单， 每个<code>Future</code>函数的错误返回都有可能不同.</p>
<blockquote>
<p>原则1: 当我们将不同的<code>Future</code>组织成一个调用<code>链</code>时，每个<code>Future</code>都应该返回相同的<code>Error Type</code>.</p>
</blockquote>
<p>让我们一起来证明一下这一点.</p>
<p>我们有两个被叫做<code>ErrorA</code>和<code>ErrorB</code>的<code>Error</code>类型,  我们将会实现<code>error::Error trait</code>,尽管这并不是编译器必须让我们做的(但是这是一个好习惯[在我看来这应该算是一个最佳实践]),在我们实现<code>error::Error trait</code>的同时还需要实现<code>std::fmt::Display</code>,现在就让我们一起实现他吧!</p>
<pre><code>#[derive(Debug, Default)]
pub struct ErrorA {}

impl fmt::Display for ErrorA {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;ErrorA!&quot;)
    }
}

impl error::Error for ErrorA {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;Description for ErrorA&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        None
    }
}

// Error B
#[derive(Debug, Default)]
pub struct ErrorB {}

impl fmt::Display for ErrorB {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;ErrorB!&quot;)
    }
}

impl error::Error for ErrorB {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;Description for ErrorB&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        None
    }
}
</code></pre>
<p>我尽量用简单的方式去实现<code>Error Trait</code>,这样可以排除别的干扰来证明我的观点. 现在让我们在<code>Future</code>中使用<code>ErrorA</code>与<code>ErrorB</code>.</p>
<pre><code>fn fut_error_a() -&gt; impl Future&lt;Item = (), Error = ErrorA&gt; {
    err(ErrorA {})
}

fn fut_error_b() -&gt; impl Future&lt;Item = (), Error = ErrorB&gt; {
    err(ErrorB {})
}
</code></pre>
<p>现在让我们在<code>main</code>函数里调用它.</p>
<pre><code>let retval = reactor.run(fut_error_a()).unwrap_err();
println!(&quot;fut_error_a == {:?}&quot;, retval);

let retval = reactor.run(fut_error_b()).unwrap_err();
println!(&quot;fut_error_b == {:?}&quot;, retval);
</code></pre>
<p>跟我们所预见的结果一致:</p>
<pre><code>fut_error_a == ErrorA
fut_error_b == ErrorB
</code></pre>
<p>到现在为止还挺好的，让我们把<code>ErrorA</code>与<code>ErrorB</code>打包成一个调用链:</p>
<pre><code>let future = fut_error_a().and_then(|_| fut_error_b());
</code></pre>
<p>我们先调用<code>fut_error_a</code>然后再调用<code>fut_error_b</code>,我们不用关心<code>fut_error_a</code>的返回值所以我们用<code>_</code>省略不用. 用更复杂的术语解释就是: 我们将<code>impl Future&lt;Item=(), Error=ErrorA&gt;</code> 和 <code>impl Future&lt;Item=(), Error=ErrorB&gt;</code>打包成调用链.</p>
<p>现在让我们尝试编译这段代码:</p>
<pre><code>
Compiling tst_fut2 v0.1.0 (file:///home/MINDFLAVOR/mindflavor/src/rust/tst_future_2)
error[E0271]: type mismatch resolving `&lt;impl futures::Future as futures::IntoFuture&gt;::Error == errors::ErrorA`
   --&gt; src/main.rs:166:32
    |
166 |     let future = fut_error_a().and_then(|_| fut_error_b());
    |                                ^^^^^^^^ expected struct `errors::ErrorB`, found struct `errors::ErrorA`
    |
    = note: expected type `errors::ErrorB`
               found type `errors::ErrorA`
</code></pre>
<p>这个报错非常明显, 编译器期待我们使用<code>ErrorB</code>但是我们给了一个<code>ErrorA</code>。</p>
<blockquote>
<p>原则2: 当我们组织<code>Future Chain</code>时，第一个错误类型必须与最后一个<code>future</code>返回的错误类型一致.(When chaining futures, the first function error type must be the same as the chained one.)</p>
</blockquote>
<p><code>rustc</code>已经非常明确的告诉我们了. 这个<code>Future chain</code>最终返回的是<code>ErrorB</code>所以我们第一个函数也应该返回<code>ErrorB</code>. 在上述代码我们返回了<code>ErrorA</code>, 所以导致编译失败.</p>
<p>我们改如何处理这个问题?非常幸运的是, 我们可以使用<code>Rust Future</code>给我们提供的<code>map_err</code>方法. 在我们的示例中，我们想要把<code>ErrorA</code>转换成<code>ErrorB</code>,所以我们只需要在<code>ErrorA</code>与<code>ErrorB</code>之间调用这个函数就行了.</p>
<pre><code>let future = fut_error_a()
    .map_err(|e| {
        println!(&quot;mapping {:?} into ErrorB&quot;, e);
        ErrorB::default()
    })
    .and_then(|_| fut_error_b());

let retval = reactor.run(future).unwrap_err();
println!(&quot;error chain == {:?}&quot;, retval);
</code></pre>
<p>如果我们现在编译并运行示例，将会输出：</p>
<pre><code>mapping ErrorA into ErrorB
error chain == ErrorB
</code></pre>
<p>让我们进一步推动这个例子.假设我们想连接ErrorA，然后是ErrorB，然后再连接ErrorA。 就像是：</p>
<pre><code>let future = fut_error_a()
    .and_then(|_| fut_error_b())
    .and_then(|_| fut_error_a());
</code></pre>
<p>我们最初的解决方式只适合成对的<code>future</code>， 并没有考虑其他的情况。所以在上面代码中我们不得不这么做:<br>
<code>ErrorA =&gt; ErrorB =&gt; ErrorA</code>.就像这样:</p>
<pre><code>let future = fut_error_a()
    .map_err(|_| ErrorB::default())
    .and_then(|_| fut_error_b())
    .map_err(|_| ErrorA::default())
    .and_then(|_| fut_error_a());
</code></pre>
<p>看上去不那么优雅但是还是解决了多个<code>Future</code>的错误处理.</p>
<h2 id="from-to-the-rescue">&quot;From&quot; to the rescue</h2>
<p>简化上述代码的一种简单的方式就是利用<code>std::covert::From</code>. 当我们实现<code>From</code>, 这样编译器就可以自动的将一个结构软换为另一个结构.现在让我们实现<code>From&lt;ErrorA&gt; for ErrorB</code>和<code>From&lt;ErrorB&gt; for ErrorA</code>.</p>
<pre><code>impl From&lt;ErrorB&gt; for ErrorA {
    fn from(e: ErrorB) -&gt; ErrorA {
        ErrorA::default()
    }
}

impl From&lt;ErrorA&gt; for ErrorB {
    fn from(e: ErrorA) -&gt; ErrorB {
        ErrorB::default()
    }
}
</code></pre>
<p>通过上述的实现我们只需要用<code>from_err</code>函数来代替<code>map_err</code>就好了。</p>
<pre><code>let future = fut_error_a()
   .from_err()
   .and_then(|_| fut_error_b())
   .from_err()
   .and_then(|_| fut_error_a());
</code></pre>
<p>现在的代码仍然与错误转换混合, 但转换代码不再是内联的，而且代码可读性也提高了。<code>Futrue Crate</code>非常聪明:只有在错误的情况下才会调用<code>from_err</code>代码， 因此在不使用<code>from_err</code>时, 也不会在<code>Runtime</code>时产生额外的开销.</p>
<h2 id="lifetimes">Lifetimes</h2>
<p>Rust签名功能是引用的显式生命周期注释. 但是，大多数情况下，Rust允许我们避免使用生命周期省略来指定生命周期.让我们看看它的实际效果. 我们想编写一个带字符串引用的函数，如果成功则返回相同的字符串引用：</p>
<pre><code>fn my_fn_ref&lt;'a&gt;(s: &amp;'a str) -&gt; Result&lt;&amp;'a str, Box&lt;Error&gt;&gt; {
    Ok(s)
}
</code></pre>
<p>注意代码中 <code>&lt;'a&gt;</code> 的部分, 意思是我们显示的声明一个<code>生命周期</code>. 接着我们声明了一个引用形参<code>s: &amp;'a str</code>, 这个参数必须在<code>'a</code>生命周期有效的情况下使用.使用<code>Result &lt;＆'str，Box &lt;Error &gt;&gt;</code>，我们告诉<code>Rust</code>我们的返回值将包含一个字符串引用.只要'a有效，该字符串引用必须有效.换句话说，传递的字符串引用和返回的对象必须具有相同的生命周期.这会导致我们的语法非常冗长，以至于Rust允许我们避免在常见情况下指定生命周期。 所以我们可以这样重写函数：</p>
<pre><code>fn my_fn_ref(s: &amp;str) -&gt; Result&lt;&amp;str, Box&lt;Error&gt;&gt; {
    Ok(s)
}
</code></pre>
<p>但是在<code>Future</code>中你不能这样写， 让我们来尝试用<code>Future</code>方式复写这个函数:</p>
<pre><code>fn my_fut_ref_implicit(s: &amp;str) -&gt; impl Future&lt;Item = &amp;str, Error = Box&lt;Error&gt;&gt; {
    ok(s)
}
</code></pre>
<p>编译将会失败(<code>rustc 1.23.0-nightly (2be4cc040 2017-11-01</code>)：</p>
<pre><code>Compiling tst_fut2 v0.1.0 (file:///home/MINDFLAVOR/mindflavor/src/rust/tst_future_2)
error: internal compiler error: /checkout/src/librustc_typeck/check/mod.rs:633: escaping regions in predicate Obligation(predicate=Binder(ProjectionPredicate(ProjectionTy { substs: Slice([_]), item_def_id: DefId { krate: CrateNum(15), index: DefIndex(0:330) =&gt; futures[59aa]::future[0]::Future[0]::Item[0] } }, &amp;str)),depth=0)
  --&gt; src/main.rs:39:36
   |
39 | fn my_fut_ref_implicit(s: &amp;str) -&gt; impl Future&lt;Item = &amp;str, Error = Box&lt;Error&gt;&gt; {
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

note: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports

note: rustc 1.23.0-nightly (2be4cc040 2017-11-01) running on x86_64-unknown-linux-gnu

thread 'rustc' panicked at 'Box&lt;Any&gt;', /checkout/src/librustc_errors/lib.rs:450:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>当然也有解决方式，我们只要显示声明一个有效的生命周期就行了:</p>
<pre><code>fn my_fut_ref&lt;'a&gt;(s: &amp;'a str) -&gt; impl Future&lt;Item = &amp;'a str, Error = Box&lt;Error&gt;&gt; {
    ok(s)
}
</code></pre>
<h2 id="impl-future-with-lifetimes">impl Future with lifetimes</h2>
<p>在<code>Future</code>中如果有引用传参我们必须要显示的注释生命周期. 举个例子, 我们希望使用<code>&amp;s</code>的值并且返回的是一个没有引用的<code>String</code>.我们必须显示的注释生命周期:</p>
<pre><code>fn my_fut_ref_chained&lt;'a&gt;(s: &amp;'a str) -&gt; impl Future&lt;Item = String, Error = Box&lt;Error&gt;&gt; {
    my_fut_ref(s).and_then(|s| ok(format!(&quot;received == {}&quot;, s)))
}
</code></pre>
<p>上面的代码将会报错:</p>
<pre><code>error[E0564]: only named lifetimes are allowed in `impl Trait`, but `` was found in the type `futures::AndThen&lt;impl futures::Future, futures::FutureResult&lt;std::string::String, std::boxed::Box&lt;std::error::Error + 'static&gt;&gt;, [closure@src/main.rs:44:28: 44:64]&gt;`
  --&gt; src/main.rs:43:42
   |
43 | fn my_fut_ref_chained&lt;'a&gt;(s: &amp;'a str) -&gt; impl Future&lt;Item = String, Error = Box&lt;Error&gt;&gt; {
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>为了解决这个错误我们必须为<code>impl Future</code>追加一个<code>'a</code>生命周期：</p>
<pre><code>fn my_fut_ref_chained&lt;'a&gt;(s: &amp;'a str) -&gt; impl Future&lt;Item = String, Error = Box&lt;Error&gt;&gt; + 'a {
    my_fut_ref(s).and_then(|s| ok(format!(&quot;received == {}&quot;, s)))
}
</code></pre>
<p>现在你可以运行这段代码了:</p>
<pre><code>let retval = reactor
    .run(my_fut_ref_chained(&quot;str with lifetime&quot;))
    .unwrap();
println!(&quot;my_fut_ref_chained == {}&quot;, retval);
</code></pre>
<h2 id="closing-remarks">Closing remarks</h2>
<p>在下一篇文章中，我们将介绍<code>Reactor</code>。 我们还将从头开始编写未来的实现结构。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入浅出Rust Future - Part 1]]></title>
        <id>https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part-1</id>
        <link href="https://www.rustc.io/post/shen-ru-qian-chu-rust-future-part-1">
        </link>
        <updated>2020-02-08T18:26:25.000Z</updated>
        <content type="html"><![CDATA[<p>译自<a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-1-3k3">Rust futures: an uneducated, short and hopefully not boring tutorial - Part 1</a></p>
<h1 id="intro">Intro</h1>
<p>如果你是一个程序员并且也喜欢Rust这门语言, 那么你应该经常在社区听到讨论<code>Future</code> 这个库的声音, 一些很优秀的<code>Rust Crates</code>都使用了<code>Future</code> 所以我们也应该对它有足够的了解并且使用它. 但是大多数程序员很难理解<code>Future</code>到底是怎么工作的, 当然有官方 <code>Crichton's tutorial</code>这样的教程, 虽然很完善, 但我还是很难理解并把它付诸实践.</p>
<p>我猜测我并不是唯一一个遇到这样问题的程序员, 所以我将分享我自己的最佳实践, 希望这能帮助你理解这个话题.</p>
<h2 id="futures-in-a-nutshell">Futures in a nutshell</h2>
<p><code>Future</code> 是一个不会立即执行的特殊<code>functions</code>. 他会在将来执行(这也是他被命名为<code>future</code>的原因).我们有很多理由让<code>future functions</code>来替代<code>std functions</code>，例如: <code>优雅</code>，<code>性能</code>，<code>可组合性</code>.<code>future</code>的缺点也很明显: 很难用代码去实现. 当你不知道何时会执行某个函数时, 你又怎么能理解他们之间的因果关系呢？</p>
<p>处于这个原因， Rust会试图帮助我们这些菜鸟程序员去理解和使用<code>future</code>这个特性。</p>
<h2 id="rusts-futures">Rust's futures</h2>
<p>Rust 的<code>futures</code> 总是一个<code>Results</code>: 这意味着你必须同时指定期待的返回值和备用的错误类型。<br>
让我们先简单的实现一个方法，然后把它改造成<code>future</code>. 我们设计的这个方法返回值是 <code>u32</code> 或者是一个 被<code>Box</code>包围着的<code>Error trait</code>， 代码如下所示:</p>
<pre><code>fn my_fn() -&gt; Result&lt;u32, Box&lt;Error&gt;&gt; {
    Ok(100)
}
</code></pre>
<p>这段代码很简单，看起来并没有涉及到<code>future</code>. 接下来让我们看看下面的代码:</p>
<pre><code>fn my_fut() -&gt; impl Future&lt;Item = u32, Error = Box&lt;Error&gt;&gt; {
    ok(100)
}
</code></pre>
<p>注意这两段代码不同的地方:</p>
<ol>
<li>返回的类型不再是<code>Result</code>而是一个<code>impl Future</code>. <code>Rust Nightly</code>版本是允许我们返回一个<code>future</code>的。</li>
<li>第二个函数返回值的参量<code>Item = u32, Error = Box&lt;Error&gt;</code>较第一个函数来看更加详细明确。</li>
</ol>
<blockquote>
<p>为了能让第二段代码工作 你需要使用拥有<code>conservative_impl_trait</code>特性的<code>nightly</code>版本。当然，如果不嫌麻烦,你可以使用<code>boxed trait</code>来替代。</p>
</blockquote>
<p>另请注意第一个函数返回值使用的是大写的<code>Ok(100)</code>。 在<code>Result</code>函数中，我们使用大写的<code>Ok</code>枚举，而<code>future</code>我们使用小写的ok方法.</p>
<blockquote>
<p>规则: 在Rust<code>future</code>中使用小写返回方法<code>ok(100)</code>.</p>
</blockquote>
<p>好了现在我们改造完毕了，但是我们该怎样执行第二个我们改造好的方法？标准方法我们可以直接调用，但是这里需要注意的是地一个方法返回值是一个<code>Result</code>, 所以我们需要使用<code>unwrap()</code>来获取我们期待的值。</p>
<pre><code>let retval = my_fn().unwrap();
println!(&quot;{:?}&quot;, retval);
</code></pre>
<p>由于<code>future</code>在实际执行之前返回(或者更准确的说, 返回的是我们将来要执行的代码), 我们需要一种途径去执行<code>future</code>。为此我们使用<code>Reactor</code>。我们只需要创建一个<code>Reactor</code>并且调用他的<code>run</code>方法就可以执行<code>future</code>. 就像下面的代码：</p>
<pre><code>let mut reactor = Core::new().unwrap();

let retval = reactor.run(my_fut()).unwrap();
println!(&quot;{:?}&quot;, retval);

</code></pre>
<p>注意这里我们<code>unwrap</code>的是<code>run</code>方法，而不是<code>my_fut</code>.<br>
看起来真的很简单。</p>
<h2 id="chaining">Chaining</h2>
<p><code>future</code>一个很重要的特性就是能够把其他的<code>future</code>组织起来形成一个<code>chain</code>. 举个栗子:</p>
<blockquote>
<p>你邀请你的父母一起吃晚饭通过email.<br>
你在电脑前等待他们的回复<br>
父母同意与你一起吃晚饭(或者因为一些原因拒绝了)。</p>
</blockquote>
<p><code>Chaining</code>就是这样的，让我们看一个简单的例子：</p>
<pre><code>fn my_fn_squared(i: u32) -&gt; Result&lt;u32, Box&lt;Error&gt;&gt; {
    Ok(i * i)
}


fn my_fut_squared(i: u32) -&gt; impl Future&lt;Item = u32, Error = Box&lt;Error&gt;&gt; {
    ok(i * i)
}
</code></pre>
<p>现在我们可以使用下面的方式去调用这两个函数：</p>
<pre><code>let retval = my_fn().unwrap();
println!(&quot;{:?}&quot;, retval);

let retval2 = my_fn_squared(retval).unwrap();
println!(&quot;{:?}&quot;, retval2);
</code></pre>
<p>当然我们也可以模拟<code>Reactor</code>来执行相同的代码:</p>
<pre><code>let mut reactor = Core::new().unwrap();

let retval = reactor.run(my_fut()).unwrap();
println!(&quot;{:?}&quot;, retval);

let retval2 = reactor.run(my_fut_squared(retval)).unwrap();
println!(&quot;{:?}&quot;, retval2);
</code></pre>
<p>但还有更好的方法，在Rust中<code>future</code>也是一个<code>trait</code>他有很多种方法(这里我们会介绍些)，其中一个名为<code>and_then</code>的方法，在语义上完全符合我们最后写的代码片段。但是没有显式的执行<code>Reactor Run</code>, 让我们一起来看看下面的代码：</p>
<pre><code>let chained_future = my_fut().and_then(|retval| my_fut_squared(retval));
let retval2 = reactor.run(chained_future).unwrap();
println!(&quot;{:?}&quot;, retval2);
</code></pre>
<p>让我们看看第一行:创建一个被叫做<code>chained_future</code>的<code>future</code>， 它把<code>my_fut</code>与<code>mu_fut_squared``future</code>串联了起来。<br>
这里让人难以理解的部分是: 我们如何将上一个<code>future</code>的结果传递给下一个<code>future</code>?</p>
<blockquote>
<p>在Rust中我们可以通过闭包来捕获外部变量来传递<code>future</code>的值。</p>
</blockquote>
<p>可以这样想：</p>
<ol>
<li>调度并且执行<code>my_fut()</code></li>
<li>当<code>my_fut()</code>执行完毕后，创建一个<code>retval</code>变量并且将<code>my_fut()</code>的返回值存到其中。</li>
<li>现在将<code>retval</code>作为<code>my_fn_squared(i: u32)</code>的参数传递进去，并且调度执行<code>my_fn_squared</code>。</li>
<li>把上面一些列的操作打包成一个名为<code>chained_future</code>的调用链。</li>
</ol>
<p>第二行代码,与之前的相同: 我们调用<code>Reactor run()</code>, 要求执行<code>chained_future</code>并给出结果。</p>
<p>当然我们可以通过这种方式将无数个<code>future</code>打包成一个<code>chain</code>, 不要去担心性能问题, 因为<code>future chain</code>是 <code>zero cost</code>.</p>
<blockquote>
<p>RUST <code>borrow checked</code>可能让你的<code>future chain</code> 写起来不是那么的轻松，所以你可以尝试<code>move</code>你的参数变量.</p>
</blockquote>
<h2 id="mixing-futures-and-plain-functions">Mixing futures and plain functions</h2>
<p>你也可以使用普通的函数来做<code>future chain</code>, 这很有用， 因为不是每个功能都需要使用<code>future</code>. 此外， 你也有可能希望调用外部你无法控制的函数。<br>
如果函数没有返回Result，你只需在闭包中添加函数调用即可。 例如，如果我们有这个普通函数：</p>
<pre><code>fn fn_plain(i: u32) -&gt; u32 {
    i - 50
}

let chained_future = my_fut().and_then(|retval| {
    let retval2 = fn_plain(retval);
    my_fut_squared(retval2)
});

let retval3 = reactor.run(chained_future).unwrap();
println!(&quot;{:?}&quot;, retval3);
</code></pre>
<p>如果你的函数返回<code>Result</code>则有更好的办法。我们一起来尝试将<code>my_fn_squared(i: u32) -&gt; Result&lt;u32, Box&lt;Error&gt;</code>方法打包进<code>future chain</code>。</p>
<p>在这里由于返回值是<code>Result</code>所以你无法调用<code>and_then</code>, 但是<code>future</code>有一个方法<code>done()</code>可以将<code>Result</code>转换为<code>impl Future</code>.这意味着我们可以将普通的函数通过<code>done</code>方法把它包装成一个<code>future</code>.</p>
<pre><code>let chained_future = my_fut().and_then(|retval| {
    done(my_fn_squared(retval)).and_then(|retval2| my_fut_squared(retval2))
});
let retval3 = reactor.run(chained_future).unwrap();
println!(&quot;{:?}&quot;, retval3);
</code></pre>
<p>注意第二：<code>done(my_fn_squared(retval))</code>允许我们在链式调用的原因是:我们将普通函数通过<code>done</code>方法转换成一个<code>impl Future</code>. 现在我们不使用<code>done</code>方法试试:</p>
<pre><code>let chained_future = my_fut().and_then(|retval| {
    my_fn_squared(retval).and_then(|retval2| my_fut_squared(retval2))
});
let retval3 = reactor.run(chained_future).unwrap();
println!(&quot;{:?}&quot;, retval3);
</code></pre>
<p>编译不通过!</p>
<pre><code>Compiling tst_fut2 v0.1.0 (file:///home/MINDFLAVOR/mindflavor/src/rust/tst_future_2)
error[E0308]: mismatched types
   --&gt; src/main.rs:136:50
    |
136 |         my_fn_squared(retval).and_then(|retval2| my_fut_squared(retval2))
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found anonymized type
    |
    = note: expected type `std::result::Result&lt;_, std::boxed::Box&lt;std::error::Error&gt;&gt;`
               found type `impl futures::Future`

error: aborting due to previous error

error: Could not compile `tst_fut2`.
</code></pre>
<p><code>expected type std::result::Result&lt;_, std::boxed::Box&lt;std::error::Error&gt;&gt; found type impl futures::Future</code>,这个错误有点让人困惑. 我们将会在第二部分讨论它。</p>
<h2 id="generics">Generics</h2>
<p>最后但并非最不重要的， <code>future</code> 与 <code>generic</code>(这是啥玩意儿啊)一起工作不需要任何黑魔法.</p>
<pre><code>fn fut_generic_own&lt;A&gt;(a1: A, a2: A) -&gt; impl Future&lt;Item = A, Error = Box&lt;Error&gt;&gt;
where
    A: std::cmp::PartialOrd,
{
    if a1 &lt; a2 {
        ok(a1)
    } else {
        ok(a2)
    }
}
</code></pre>
<p>这个函数返回的是 a1 与 a2之间的较小的值。但是即便我们很确定这个函数没有错误也需要给出<code>Error</code>，此外，返回值在这种情况下是小写的<code>ok</code>(原因是函数， 而不是<code>enmu</code>)</p>
<p>现在我们调用这个<code>future</code>:</p>
<pre><code>let future = fut_generic_own(&quot;Sampdoria&quot;, &quot;Juventus&quot;);
let retval = reactor.run(future).unwrap();
println!(&quot;fut_generic_own == {}&quot;, retval);
</code></pre>
<p>阅读到现在你可能对<code>future</code>应该有所了解了， 在这边文章里你可能注意到我没有使用<code>&amp;</code>, 并且仅使用函数自身的值。这是因为使用<code>impl Future</code>，生命周期的行为并不相同，我将在下一篇文章中解释如何使用它们。在下一篇文章中我们也会讨论如何在<code>future chain</code>处理错误和使用await!()宏。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建一个简单的k8s应用]]></title>
        <id>https://www.rustc.io/post/chuang-jian-yi-ge-jian-dan-de-k8s-ying-yong</id>
        <link href="https://www.rustc.io/post/chuang-jian-yi-ge-jian-dan-de-k8s-ying-yong">
        </link>
        <updated>2020-02-08T18:25:51.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="创建k8s应用">创建K8S应用</h1>
<h2 id="前言">前言</h2>
<p>从创建Docker Container开始一步一步给大家讲述如何创建自己的K8S应用.看懂这篇操作手册你可能需要<br>
了解:</p>
<ol>
<li>Docker 命令的使用</li>
<li>kubectl 命令的使用</li>
<li>Yaml的使用</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h1 id="创建k8s应用">创建K8S应用</h1>
<h2 id="前言">前言</h2>
<p>从创建Docker Container开始一步一步给大家讲述如何创建自己的K8S应用.看懂这篇操作手册你可能需要<br>
了解:</p>
<ol>
<li>Docker 命令的使用</li>
<li>kubectl 命令的使用</li>
<li>Yaml的使用</li>
</ol>
<!-- more -->
<h2 id="概念">概念</h2>
<h5 id="docker">Docker</h5>
<ul>
<li>Docker Registry是什么？
<ul>
<li>他是存储docker镜像的仓库, 如果你熟悉git，那么上手这个也很快, 你需要了解到的几个命令:</li>
<li>docker push (上传镜像)</li>
<li>docker pull (拉取镜像)</li>
</ul>
</li>
</ul>
<blockquote>
<p>常用的仓储有 https://index.docker.io</p>
</blockquote>
<ul>
<li>
<p>Docker Container 与 Docker Image 之间的关系？</p>
<ul>
<li>所有的Docker Container 都是以 Docker Image为蓝本创建的</li>
<li>Docker Image 可以理解为一个还没装到你电脑上的Win7系统镜像，Docker Container是已经装到你的电脑上的系统.</li>
</ul>
</li>
<li>
<p>如何基于Dockerfile创建一个Docker Container？</p>
</li>
</ul>
<pre><code># Docker Hub 拉取ubuntu 基础镜像，并以它为蓝本创建自己的镜像
FROM ubuntu
# 维护者
MAINTAINER docker_user docker_user@email.com
# 更新ubuntu系统
RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list
# 安装Nginx
RUN apt-get update &amp;&amp; apt-get install -y nginx
# 为了保证容器与nginx生命周期一致，所有的程序不建议用background的方式运行
RUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf
# Docker Container 运行时需要执行的命令
CMD /usr/sbin/nginx
</code></pre>
<h6 id="k8s">K8S</h6>
<ul>
<li>
<p>POD 是什么？</p>
<ul>
<li>是K8S里最小可运行的单元，一个POD里至少需要一个Docker Container。</li>
</ul>
</li>
<li>
<p>Service 是什么？</p>
<blockquote>
<p>Container需要对外服务，以Nginx为例子，来描述Service创建过程</p>
</blockquote>
<ol>
<li>Container 暴露一个端口映射到POD端口上(K8S会分给POD一个内部的Cluster IP)</li>
<li>POD 暴露出相应的端口。</li>
<li>Service 通过K8S的Label标签功能,发现POD，以及POD暴露出来的端口</li>
</ol>
</li>
<li>
<p>Ingress 是什么</p>
<ul>
<li>Ingress是一个互联网入口，可以看做一个简单的Nginx，Ingress通过KUBE-PROXY将外部访问流量引导至Service上</li>
</ul>
</li>
</ul>
<h2 id="创建流程">创建流程</h2>
<blockquote>
<p>main.go</p>
</blockquote>
<pre><code class="language-golang">package main

import (
    &quot;net/http&quot;
)

func SayHello(w http.ResponseWriter, req *http.Request) {
    w.Write([]byte(&quot;Hello World&quot;))
}

func main() {
    http.HandleFunc(&quot;/hello&quot;, SayHello)
    http.ListenAndServe(&quot;:8001&quot;, nil)

}
</code></pre>
<h5 id="创建基准docker-image">创建基准Docker Image</h5>
<pre><code class="language-bash"># 以BusyBox做为基准镜像创建我们自己的Docker Image
FROM busybox
# 设置工作目录
WORKDIR /go/src/app
# 把当前目录的二进制文件放到Docker Images
COPY . .
# 纠正时间
RUN  cp -r -f Shanghai /etc/localtime &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone 
# 运行时执行的命令
CMD [&quot;/go/src/app/helloworld&quot;]
</code></pre>
<h5 id="创建pod">创建POD</h5>
<blockquote>
<p>deployment.yaml</p>
</blockquote>
<pre><code class="language-yaml"># 使用k8s哪一个版本的API
apiVersion: extensions/v1beta1 
# 以Deployment方式创建POD， 这里有很多类型以后有机会再讲
kind: Deployment
metadata:
  # 创建的POD名字K8S内部会hash这个值
  name: helloworld
  # 指定在哪个namespace下创建
  namespace: frm
spec:
  # 部署副本数量
  replicas: 3
  # 保留历史版本的副本数量的上限值
  revisionHistoryLimit: 5
  template:
    metadata:
      labels:
        # Service 通过这个值讲 SVC与POD关联上
        app: helloworld
        version: production
    spec:
      containers:
      # 创建的ContainerName
      - name: helloworld
        # docker image 地址
        image: helloworld:v1.3
        # 触发滚动更新的规则
        imagePullPolicy: IfNotPresent
        # 资源限制
        resources:
          limits:
            cpu: 80m
            memory: 80Mi
          requests:
            cpu: 20m
            memory: 20Mi 
        # container 暴露出来的端口
        ports:
        - name: helloworld-port
          containerPort: 80
        # 挂载目录  
        volumeMounts:
        - mountPath: /go/src/app/logs
          name: log  
     # 指定该POD卷挂载到宿主机目录
      volumes:
      - name: log
        hostPath:
          path: /home/data/logs/helloworld # 宿主及目录
          type: Directory

</code></pre>
<h5 id="创建service">创建Service</h5>
<blockquote>
<p>service.yaml</p>
</blockquote>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: helloworld-srv
  namespace: frm
  labels:
    # Service 的Label, Ingress通过这个来关联Service
    app: helloworld-srv
    version: production
spec:
  type: ClusterIP
  selector:
    # 选择一个POD Label
    app: helloworld
    version: production
  # 选择POD暴露的端口  
  ports:
    - name: http
      port: 80
</code></pre>
<h5 id="创建ingress">创建Ingress</h5>
<blockquote>
<p>ingress.yaml</p>
</blockquote>
<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: helloworld-ingress
  namespace: frm
  labels:
    app: helloworld-ingress
spec:
  rules:
  ### 指定域名
  - host: helloworld.test
    http:
      paths:
      - path: /
        backend:
          # 选择绑定哪个service
          serviceName: helloworld-srv
          servicePort: 80
</code></pre>
<h5 id="创建命令">创建命令</h5>
<blockquote>
<p>kubectl create -f deployment.yaml service.yaml ingress.yaml</p>
</blockquote>
<h2 id="流程">流程</h2>
<blockquote>
<p>User Request -&gt; Ingress Port-&gt; Service -&gt; Pod -&gt; Container</p>
</blockquote>
<h2 id="问题排查">问题排查</h2>
<ol>
<li>
<p>构建Docker Image后先自己 docker run 一下来确认构建是否是成功的!</p>
</li>
<li>
<p>创建失败 ，查看POD创建状态</p>
</li>
</ol>
<ul>
<li><code>kubectl describe pods POD_NAME -n NAMESPACE</code></li>
</ul>
<ol start="3">
<li>创建失败 ，查看POD LOG</li>
</ol>
<ul>
<li><code>kubectl log POD_NAME -n NAMESPACE</code></li>
</ul>
<ol start="4">
<li>POD启动成功但是无法访问</li>
</ol>
<ul>
<li><code>kubectl get svc,ingresss,pod -n NAMESPACE</code></li>
</ul>
<ol start="5">
<li>查看service的状态</li>
</ol>
<ul>
<li><code>kubectl exec -it POD_NAME -n NAMESPACE -c CONTAINER_NAME</code>，进入有问题的容器看看</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[kubernetes 容器应用]]></title>
        <id>https://www.rustc.io/post/kubernetes-rong-qi-ying-yong</id>
        <link href="https://www.rustc.io/post/kubernetes-rong-qi-ying-yong">
        </link>
        <updated>2020-02-08T18:22:53.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>上一篇文章简单的介绍了<code>Kubernetes</code>内部的负载均衡原理，有朋友在群里反映不要一上来就将原理，想了想也是，那我就从如何创建一个<code>PHP Web</code>应用入手，带大家进入<code>Kubernetes</code>的世界。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>上一篇文章简单的介绍了<code>Kubernetes</code>内部的负载均衡原理，有朋友在群里反映不要一上来就将原理，想了想也是，那我就从如何创建一个<code>PHP Web</code>应用入手，带大家进入<code>Kubernetes</code>的世界。</p>
<!-- more --> 
<h2 id="基础">基础</h2>
<h3 id="环境">环境</h3>
<ul>
<li>CentOS 7.5 (Kernel 3.10)</li>
<li>Minikube (Kubernetes 1.10.0)</li>
</ul>
<h3 id="对你的要求">对你的要求</h3>
<p>我假设你已经掌握了下面的基础技能:</p>
<ul>
<li>Docker &amp;&amp; 会写Dockerfile</li>
<li>如何Google</li>
<li>拥有一个DockerHub账号</li>
<li>手动编译过LNMP或者LAMP</li>
</ul>
<h1 id="构建基础镜像">构建基础镜像</h1>
<p>上图描述了我们需要创建的<code>Containers</code>，其中<code>Pause Container</code>是<code>Kubernetes</code>自带的所以我们不用关心，但是十分重要，未来将会有一篇文章来描述<code>Pause Container</code>到底干什么的。<br>
其实基础镜像一般用官方现成的就行了，但是在学习过程中建议还是手动编译一下，了解下官方默认配置有哪些坑。<code>Dockerfile</code>代码我会放到<code>GitHub</code>上, 因为在这里展示实在是太长了。</p>
<h2 id="创建nginx镜像">创建Nginx镜像</h2>
<p><code>Nginx</code>: <a href="https://github.com/motecshine/nginx1.12-for-k8s">Nginx For K8S GitHub Repo</a></p>
<h3 id="编译nginx镜像">编译Nginx镜像</h3>
<pre><code class="language-Shell">    docker build . -t motecshine/nginx1.12-for-k8s:v0.1.0
    docker push motecshine/nginx1.12-for-k8s:v0.1.0
</code></pre>
<h2 id="创建php-fpm镜像">创建PHP-FPM镜像</h2>
<p><code>FPM</code>: <a href="https://github.com/motecshine/php71-for-k8s">FPM For K8S GitHub Repo</a></p>
<h3 id="编译fpm镜像">编译FPM镜像</h3>
<pre><code class="language-Shell">    docker build . -t motecshine/php71-for-k8s:v0.1.0
    docker push motecshine/php71-for-k8s:v0.1.0
</code></pre>
<blockquote>
<p>注意事项: <code>Dockerfile</code> <code>CMD</code> 需要关闭<code>Nginx</code> 和 <code>FPM</code>的<code>daemon</code>特性，具体看我REPO的<code>Dockerfile</code>， 这样是为了保证<code>Container</code>生命周期与<code>POD</code>生命周期一致。</p>
</blockquote>
<h1 id="构建业务镜像">构建业务镜像</h1>
<p>我们将基于上述镜像来创建我们的业务镜像.</p>
<h2 id="创建code镜像">创建Code镜像</h2>
<p>我们基于<code>Laravel</code>来创建镜像。</p>
<p><code>Code</code>: <a href="https://github.com/motecshine/code-for-k8s">Code For K8S GitHub Repo</a></p>
<h3 id="编译code镜像">编译Code镜像</h3>
<pre><code class="language-Shell">    docker build . -t motecshine/code-for-k8s:v0.1.1
    docker push motecshine/code-for-k8s:v0.1.1
</code></pre>
<h2 id="创建nginx镜像-2">创建Nginx镜像</h2>
<p><code>laravel-nginx-for-k8s</code>: <a href="https://github.com/motecshine/laravel-nginx-for-k8s">Laravel For K8S GitHub Repo</a></p>
<h3 id="编译nginx镜像-2">编译Nginx镜像</h3>
<pre><code class="language-Shell">    docker build . -t  motecshine/laravel-nginx-for-k8s:v0.1.1
    docker push  motecshine/laravel-nginx-for-k8s:v0.1.1
</code></pre>
<h2 id="创建php-fpm镜像-2">创建PHP-FPM镜像</h2>
<p><code>laravel-fpm-for-k8s</code>: <a href="https://github.com/motecshine/laravel-fpm-for-k8s">Laravel-FPM For K8S GitHub Repo</a></p>
<h3 id="编译fpm镜像-2">编译FPM镜像</h3>
<pre><code class="language-Shell">    docker build . -t  motecshine/laravel-fpm-for-k8s:v0.1.0
    docker push  motecshine/laravel-fpm-for-k8s:v0.1.0
</code></pre>
<h1 id="构建kubernetes应用">构建Kubernetes应用</h1>
<h3 id="创建deployment">创建Deployment</h3>
<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: laravel
  namespace: default
spec:
  replicas: 1 # 期待副本数量
  template:
    metadata:
      labels:
        app: laravel # app label
        version: testing
    spec:
      containers:
      - name: code
        image: motecshine/code-for-k8s:v0.1.1
        volumeMounts: # 挂载目录
        - mountPath: /data2
          name: code
      - name: fpm
        image: motecshine/laravel-fpm-for-k8s:v0.1.0
        imagePullPolicy: IfNotPresent
        resources: # 资源限制
           limits:
             cpu: 350m
             memory: 350Mi
           requests:
             cpu: 50m
             memory: 50Mi
        ports:
        - name: fpm
          containerPort: 9000
        volumeMounts:
        - mountPath: /data/code # 挂载code
          name: code
        - mountPath: /var/log # 挂载日志
          name: log  
      - name: laravel-nginx
        image: motecshine/laravel-nginx-for-k8s:v0.1.0
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            cpu: 350m
            memory: 350Mi
          requests:
            cpu: 50m
            memory: 50Mi
        ports:
        - name: laravel-nginx
          containerPort: 80 # 暴露Endpoint
        volumeMounts:
        - mountPath: /data/code
          name: code
        - mountPath: /var/log
          name: log  
      volumes:
      - name: code
        emptyDir: {}
      - name: log
        hostPath:
          path: /var/log
          type: Directory
</code></pre>
<h2 id="构建service">构建Service</h2>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: laravel-service
  namespace: default
  labels:
    app: laravel-service
    version: testing-service
spec:
  type: ClusterIP
  selector:
    app: laravel
    version: testing
  ports:
    - name: http
      port: 80
</code></pre>
<h2 id="构建ingress">构建Ingress</h2>
<pre><code class="language-yaml">
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: laravel-ingress
  namespace: default
  labels:
    app: laravel-ingress
spec:
  rules:
  - host: laravel.test
    http:
      paths:
      - path: /
        backend:
          serviceName: laravel-service
          servicePort: 80
</code></pre>
<h2 id="安装minikube">安装Minikube</h2>
<pre><code class="language-Shell">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo cp minikube /usr/local/bin/ &amp;&amp; rm minikube
</code></pre>
<h2 id="安装traefik">安装Traefik</h2>
<p>我们使用开源的<code>Ingress</code>组件安装<a href="https://docs.traefik.io/user-guide/kubernetes/">参考这里</a></p>
<h2 id="启动web应用">启动Web应用</h2>
<p><a href="https://github.com/motecshine/laravel-k8s-config.git">上面的配置文件在这里</a></p>
<pre><code class="language-Shell">git clone git@github.com:motecshine/laravel-k8s-config.git
cd laravel-k8s-config &amp;&amp; kubectl create -f .
</code></pre>
<h1 id="结语">结语</h1>
<p>简单的介绍了如何创建一个Web应用，这仅仅是个开始，<code>Kubernetes</code>背后是一个庞大的生态环境, <code>CI，CD，ELK(EFK), APM</code>，让我们一点点揭开它神秘的面纱。</p>
<p>这里挂载日志到<code>Host Path</code> 会有并发写入的问题, 下一篇将<code>Kubenetes</code>基于<code>EFK</code>日志收集平台，并且给出这个问题的解决方案。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K8s内部负载均衡原理]]></title>
        <id>https://www.rustc.io/post/k8s-nei-bu-fu-zai-jun-heng-yuan-li</id>
        <link href="https://www.rustc.io/post/k8s-nei-bu-fu-zai-jun-heng-yuan-li">
        </link>
        <updated>2020-02-08T18:14:12.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>个人理解有限，如有错误，请及时指正。</p>
</blockquote>
<p>前前后后学习<code>kubernetes</code>已经有三个月了，一直想写一遍关于<code>kubernetes</code>内部实现的一系列文章来作为这三个月的总结，个人觉得<code>kubernetes</code>背后的架构理念以及技术会成为中大型公司架构的未来。我推荐可以先阅读下Google的<a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf">Large-scale cluster management at Google with Borg</a>技术文献，它是实现<code>kubernetes</code>的基石。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>个人理解有限，如有错误，请及时指正。</p>
</blockquote>
<p>前前后后学习<code>kubernetes</code>已经有三个月了，一直想写一遍关于<code>kubernetes</code>内部实现的一系列文章来作为这三个月的总结，个人觉得<code>kubernetes</code>背后的架构理念以及技术会成为中大型公司架构的未来。我推荐可以先阅读下Google的<a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf">Large-scale cluster management at Google with Borg</a>技术文献，它是实现<code>kubernetes</code>的基石。</p>
<!-- more -->
<h2 id="准备">准备</h2>
<p>在阐述原理之前我们需要先了解下<code>kubernetes</code>关于内部负载均衡的几个基础概念以及组件。</p>
<h3 id="概念">概念</h3>
<h5 id="pod">Pod</h5>
<p>1.<code>Pod</code>是<code>Kubernetes</code>创建或部署的最小/最简单的基本单位。</p>
<p>2.如图所示，<code>Pod</code>的基础架构是由一个根容器<code>Pause Container</code>和多个业务<code>Container</code>组成的。</p>
<p>3.根容器的<code>IP</code>就是<code>Pod IP</code>，是由<code>kubernetes</code>从<code>etcd</code>中取出相应的网段分配的, <code>Container IP</code>是由<code>docker</code>分配的，同样这些<code>IP</code>相对应的<code>IP</code>网段是被存放在<code>etcd</code>里。</p>
<p>4.业务<code>Container</code>暴露出来端口并且映射到相应的根容器<code>Pause Container</code>端口，映射出来的端口叫做<code>endpoint</code>。</p>
<p>5.业务<code>Container</code>的生命周期就是<code>POD</code>的生命周期，任何一个与之相关联的<code>Container</code>死亡，<code>POD</code>也应该随之消失</p>
<h5 id="service">Service</h5>
<p>1.<code>Service</code> 是定义一系列Pod以及访问这些Pod的策略的一层抽象。<code>Service</code>通过<code>Label</code>找到<code>Pod</code>组。因为<code>Service</code>是抽象的，所以在图表里通常看不到它们的存在，这也就让这一概念更难以理解。</p>
<p>2.<code>Kubernetes</code>也会分给<code>Service</code>一个内部的<code>Cluster IP</code>，<code>Service</code>通过<code>Label</code>查询到相应的<code>Pod</code>组, 如果你的<code>Pod</code>是对外服务的那么还应该有一组<code>endpoint</code>，需要将<code>endpoint</code>绑到<code>Service</code>上，这样一个微服务就形成了。</p>
<h5 id="kubernetes-cni">Kubernetes CNI</h5>
<p>CNI（Container Network Interface）是用于配置Linux容器的网络接口的规范和库组成，同时还包含了一些插件。CNI仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p>
<h5 id="ingress">Ingress</h5>
<p>1.俗称边缘节点，假如你的<code>Service</code>是对外服务的，那么需要将<code>Cluster IP</code>暴露为对外服务，这时候就需要将<code>Ingress</code>与<code>Service</code>的<code>Cluster IP</code>与端口绑定起来对外服务。这样看来其实<code>Ingress</code>就是将外部流量引入到<code>Kubernetes</code>内部，这也是这篇文章重要要将的。</p>
<p>2.实现Ingress的开源组件有<code>Traefik</code>和<code>Nginx-Ingress</code>, 前者方便部署，后者部署复杂但是性能和灵活性更好。</p>
<h3 id="组件">组件</h3>
<h3 id="kube-proxy">Kube-Proxy</h3>
<p>1.<code>Kube-Proxy</code>是被内置在<code>Kubernetes</code>的插件。<br>
2.当<code>Service</code>与<code>Pod</code> <code>Endpoint</code>变化时，<code>Kube-Proxy</code>将会改变宿主机<code>iptables</code>, 然后配合<code>Flannel</code>或者<code>Calico</code>将流量引入<code>Service</code>.</p>
<h3 id="etcd">Etcd</h3>
<p>1.<code>Etcd</code>是一个简单的<code>Key-Value</code>存储工具。<br>
2.<code>Etcd</code>实现了<code>Raft</code>协议，这个协议主要解决<code>分布式强一致性</code>的问题，与之相似的有<code>Paxos</code>, <code>Raft</code>比<code>Paxos</code>要容易实现。<br>
3.<code>Etcd</code>用来存储<code>Kubernetes</code>的一些网络配置和其他的需要强一致性的配置，以供其他组件使用。<br>
4.如果你想要深入了解<code>Raft</code>, 不放先看看<a href="https://github.com/motecshine/simple-raft">raft相关资料</a></p>
<h3 id="flannel">Flannel</h3>
<p>1.<code>Flannel</code>是<code>CoreOS</code>团队针对<code>Kubernetes</code>设计的一个覆盖网络<code>Overlay Network</code>工具，其目的在于帮助每一个使用<code>Kuberentes</code>的<code>CoreOS</code>主机拥有一个完整的子网。<br>
2.主要解决<code>POD</code>与<code>Service</code>,<code>跨节点</code>相互通讯的。</p>
<h3 id="traefik">Traefik</h3>
<p>1.<code>Traefik</code>是一个使得部署微服务更容易的现代HTTP反向代理、负载。<br>
2.<code>Traefik</code>不仅仅是对<code>Kubernetes</code>服务的，除了<code>Kubernetes</code>他还有很多的<code>Providers</code>，如<code>Zookeeper</code>,<code>Docker Swarm</code>, <code>Etcd</code>等等</p>
<h2 id="traefik工作原理">Traefik工作原理</h2>
<p>授人以鱼不如授人以渔，我想通过我看源码的思路来抛砖引玉，给大家一个启发。</p>
<h5 id="思考">思考</h5>
<p>在我要深度了解一个组件的时候通常会做下面几件事情</p>
<ul>
<li>
<p>组件扮演的角色</p>
</li>
<li>
<p>手动编译一个版本</p>
</li>
<li>
<p>根据语言特性来了解组件初始化流程</p>
</li>
<li>
<p>看单元测试，了解函数具体干什么的</p>
</li>
<li>
<p>手动触发一个流程，在关键步骤处记录日志，单步调试</p>
</li>
</ul>
<h6 id="traefik初始化流程">Traefik初始化流程</h6>
<p>1.在<code>github.com/containous/traefik/cmd/traefik</code>下由一个名为<code>traefik.go</code>的文件是该组件的入口。<code>main()</code>方法里有这样一段代码</p>
<pre><code>
// 加载 Traefik全局配置
traefikConfiguration := cmd.NewTraefikConfiguration()
// 加载providers的配置
traefikPointersConfiguration := cmd.NewTraefikDefaultPointersConfiguration()

...

// 加载store的配置
storeConfigCmd :=storeconfig.NewCmd(traefikConfiguration, traefikPointersConfiguration)

// 获取命令行参数
f := flaeg.New(traefikCmd, os.Args[1:])
// 解析参数
f.AddParser(reflect.TypeOf(configuration.EntryPoints{}), &amp;configuration.EntryPoints{})
...

// 初始化Traefik
s := staert.NewStaert(traefikCmd)
// 加载配置文件
toml := staert.NewTomlSource(&quot;traefik&quot;, []string{traefikConfiguration.ConfigFile, &quot;/etc/traefik/&quot;, &quot;$HOME/.traefik/&quot;, &quot;.&quot;})
...
// 启动服务
if err := s.Run(); err != nil {
    fmtlog.Printf(&quot;Error running traefik: %s\n&quot;, err)
    os.Exit(1)
}

os.Exit(0)
</code></pre>
<p>上面就是组件初始化流程，当我们看完初始化流程的时候应该会想到下面几个问题：</p>
<ul>
<li>
<p>当我们手动或者自动伸缩<code>Pods</code>时，<code>Traefik</code>是怎么知道的？</p>
<p>假设你已经知道<code>Kubernets</code>是一个<code>C/S</code>架构，所有的组件都要通过<code>kube-apiserver</code>来了解其他节点或者组件的运行状态。</p>
<p>当然<code>Traefik</code>也不例外，他是通过<code>Kubernetes</code>开源的<code>Client-Go</code>SDK来完成与<code>kube-apiserver</code>交互的。</p>
<p>我们来找找源码:</p>
<blockquote>
<p><code>github.com/containous/traefik/provider/kubernetes</code>是关于<code>Kubernetes</code>的源码。我们看看到底干了啥。</p>
</blockquote>
<pre><code>
 type Client interface {
     // 检测Namespaces下的所有变动
     WatchAll(namespaces Namespaces, stopCh &lt;-chan struct{}) (&lt;-chan interface{}, error)
     // 获取边缘节点
     GetIngresses() []*extensionsv1beta1.Ingress
     // 获取Service
     GetService(namespace, name string) (*corev1.Service, bool, error)
     // 获取秘钥
     GetSecret(namespace, name string) (*corev1.Secret, bool, error)
     // 获取Endpoint
     GetEndpoints(namespace, name string) (*corev1.Endpoints, bool, error)
     // 更新Ingress状态
     UpdateIngressStatus(namespace, name, ip, hostname string) error
 }

</code></pre>
<p>显而易见，这里通过订阅<code>kube-apiserver</code>，来实时的知道<code>Service</code>的变化，从而实时更新<code>Traefik</code>。<br>
我们再来看看具体实现</p>
<pre><code>// kubernetes.go
func (p *Provider) Provide(configurationChan chan&lt;- types.ConfigMessage, pool *safe.Pool, constraints types.Constraints) error {
...
// 初始化一个kubernets client
k8sClient, err := p.newK8sClient(p.LabelSelector)
if err != nil {
    return err
}
....
// routines 连接池，这里的routines实现的很优雅，有心的同学看下
pool.Go(func(stop chan bool) {
    operation := func() error {
        for {
            stopWatch := make(chan struct{}, 1)
            defer close(stopWatch)
            // 监视和更新namespaces下的所有变动
            eventsChan, err := k8sClient.WatchAll(p.Namespaces, stopWatch)
            ....
            for {
                    select {
                    case &lt;-stop:
                        return nil
                    case event := &lt;-eventsChan:
                        // 从kubernestes 那边接收到的事件
                        log.Debugf(&quot;Received Kubernetes event kind %T&quot;, event)
                        // 加载默认template配置
                        templateObjects, err := p.loadIngresses(k8sClient)
                        ...
                        // 对比最后一次的和这次的配置有什么不同
                        if reflect.DeepEqual(p.lastConfiguration.Get(), templateObjects) {
                            // 相同的话，滤过
                            log.Debugf(&quot;Skipping Kubernetes event kind %T&quot;, event)
                        } else {
                            // 否则更新配置
                            p.lastConfiguration.Set(templateObjects)
                            configurationChan &lt;- types.ConfigMessage{
                                ProviderName:  &quot;kubernetes&quot;,
                                Configuration: p.loadConfig(*templateObjects),
                            }
                        }
                    }
            }
    }
}

</code></pre>
<p><code>Kubernets</code>返回给<code>Traefik</code>的数据结构大致是这样的:</p>
<pre><code class="language-json">{&quot;service&quot;:{&quot;pod_name&quot;:{&quot;domain&quot;:&quot;ClusterIP&quot;}}}
</code></pre>
<p>看过上述的代码分析应该就对Traefik有一个大致的了解了。</p>
</li>
</ul>
<h2 id="kube-poxy工作原理">Kube-Poxy工作原理</h2>
<p><code>Kube-Proxy</code>与<code>Traefik</code>实现原理很像，都是通过与<code>kube-apiserver</code>的交互来完成实时更新<code>iptables</code>的，这里就不细说了，以后会有一篇文章专门讲<br>
<code>kube-dns</code>, <code>kube-proxy</code>, <code>Service</code>的。</p>
<h2 id="组件协同与负载均衡">组件协同与负载均衡</h2>
<p>简单描述流程，然后思考问题，最后考虑是否需要深入了解(取决于个人兴趣)</p>
<h3 id="组件协同">组件协同</h3>
<p>用户通过访问<code>Traefik</code>提供的L7层端口, <code>Traefik</code>会转发流量到<code>Cluster IP</code>，<code>Flannel</code>会将用户的请求准确的转发到相应的<code>Node</code>节点的<code>Service</code>上。(ps:  <code>Flannel</code>初始化的时候宿主机会建立一个叫<code>flannel0</code>【这里的数字取决于你的Node节点数】的虚拟网卡）</p>
<h3 id="负载均衡">负载均衡</h3>
<p>上文讲述了<code>kube-proxy</code>是通过<code>iptables</code>来配合<code>flannel</code>完成一次用户请求的。</p>
<p>具体的流程我们只要看一个<code>service</code>的<code>iptables rules</code>就知道了。</p>
<pre><code>// 只截取了一小段，假设我们起了两个Pods
-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000
// 流量跳转至 KUBE-SVC-ILP7Z622KEQYQKOB
-A KUBE-SERVICES -d 10.111.182.127/32 -p tcp -m comment --comment &quot;pks/car-info-srv:http cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-ILP7Z622KEQYQKOB
// 50%的几率跳转至KUBE-SEP-GDPUTEQG2YTU7YON
-A KUBE-SVC-ILP7Z622KEQYQKOB -m comment --comment &quot;pks/car-info-srv:http&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-GDPUTEQG2YTU7YON

// 流量转发至真正的Service Cluster IP
-A KUBE-SEP-GDPUTEQG2YTU7YON -s 10.244.1.57/32 -m comment --comment &quot;pks/car-info-srv:http&quot; -j KUBE-MARK-MASQ
-A KUBE-SEP-GDPUTEQG2YTU7YON -p tcp -m comment --comment &quot;pks/car-info-srv:http&quot; -m tcp -j DNAT --to-destination 10.244.1.57:80
</code></pre>
<p>可以很明显的看出来，<code>kubernetes</code>内部的负载均衡是通过<code>iptables</code>的<code>probability</code>特性来做到的，这里就会有一个问题，当<code>Pod</code>副本数量过多时，<code>iptables</code>的表将会变得很大，这时会有性能问题。</p>
<h3 id="总结">总结</h3>
<ul>
<li><code>Traefik</code> 通过默认的负载均衡(wrr)直接将流量通过<code>Flannel</code>送进<code>POD</code>.</li>
<li><code>kube-proxy</code> 在没有 <code>ipvs</code>的情况下, 会通过<code>iptables</code>转发做负载均衡.</li>
</ul>
<h2 id="结尾">结尾</h2>
<p>通过这篇文章我们简单的了解到内部负载均衡的机制，但是任然不够深入，你也可用通过这篇文章查漏补缺，觉得有什么错误的地方欢迎及时指正，我的邮箱<code>shinemotec@gmail.com</code>。下一篇将会讲<code>Kubernetes</code>的<code>HPA</code>工作原理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP与PHP-FPM不得不说的二三事]]></title>
        <id>https://www.rustc.io/post/php-yu-php-fpm-bu-de-bu-shuo-de-er-san-shi</id>
        <link href="https://www.rustc.io/post/php-yu-php-fpm-bu-de-bu-shuo-de-er-san-shi">
        </link>
        <updated>2020-02-08T18:12:41.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>说起PHP，大家肯定对PHP-FPM也不陌生，因为如果做Web的话经常与它打交道，公司新建blog，我来抛砖引玉，文章有错误的地方欢迎大家指正。<br>
可能是一个系列将从 php-fpm讲起，会针对 ZendVM  词法编译，语法编译，粗暴的zend_mm和gc，zend_vm重要的数据结构(zend_array(php5 是hashtable)， zval)</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>说起PHP，大家肯定对PHP-FPM也不陌生，因为如果做Web的话经常与它打交道，公司新建blog，我来抛砖引玉，文章有错误的地方欢迎大家指正。<br>
可能是一个系列将从 php-fpm讲起，会针对 ZendVM  词法编译，语法编译，粗暴的zend_mm和gc，zend_vm重要的数据结构(zend_array(php5 是hashtable)， zval)</p>
<!-- more -->
<h2 id="sapi是什么">SAPI是什么？</h2>
<p><code>SAPI</code> 是PHP框架的接口层，他是进入PHP内部的入口，其中我们使用频率比较多的几个: CLI, PHP-FPM,  ApacheHandler2(php 5.6以前经常使用,  php-ng 以后从官方的标准SAPI库中移除) ，都实现了SAPI Interface。</p>
<h2 id="php-fpm是什么">PHP-FPM是什么？</h2>
<p>说起FPM(FastCGI Process Manager)，不得不先说说FastCGI。<br>
FastCGI 是Web程序和处理程序之间的一种通信协议，他是与HTTP类似的一种应用层通信的协议。注意：FastCGI 是一种协议<br>
PHP本身不像GO 那样实现HTTP协议(第三方库 Swoole 有实现)，而是实现了 FastCGI协议。<br>
FPM 就是解析和管理FastCGI Pool</p>
<h2 id="php-fpm-工作原理">PHP-FPM 工作原理</h2>
<pre><code class="language-c">fpm.c
/*	children: return listening socket
	parent: never return */
int fpm_run(int *max_requests) /* {{{ */
{
	struct fpm_worker_pool_s *wp;

	/* create initial children in all pools */
	for (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) {
		int is_parent;

		is_parent = fpm_children_create_initial(wp);

		if (!is_parent) {
			goto run_child;
		}

		/* handle error */
		if (is_parent == 2) {
			fpm_pctl(FPM_PCTL_STATE_TERMINATING, FPM_PCTL_ACTION_SET);
			fpm_event_loop(1);
		}
	}

	/* run event loop forever */
	fpm_event_loop(0);

run_child: /* only workers reach this point */

	fpm_cleanups_run(FPM_CLEANUP_CHILD);

	*max_requests = fpm_globals.max_requests;
	return fpm_globals.listening_socket;
}
/* }}} */

</code></pre>
<h3 id="三种进程管理方式">三种进程管理方式</h3>
<ul>
<li>
<p>静态模式:<br>
在启动的时候 master根据pm.max_children配置fork出相应数量地worker进程，woker的数量是固定的。</p>
</li>
<li>
<p>动态模式(dynamic)：<br>
这种模式应该是最常用的， fpm 启动时会根据pm.start_servers配置初始化一定数量的worker。 如果master发现空闲woker低于pm.min_spare_servers配置数则会fork出更多的woker进程，但是不会超过pm.max_spare_servers, 如果master发现了空闲的woker 大于 pm.max_spare_servers 则会杀死部分woker。</p>
</li>
<li>
<p>按需(ondemand)：<br>
启动时，不分配woker，请求来了 master 才会fork，但是不会超过pm.max_children。请求流程完了也不会立马kill woker，当woker的空闲时间超过pm.oricess_idle_timeout才会被杀死</p>
</li>
</ul>
<h3 id="工作流程">工作流程</h3>
<p>FPM 是一个多进程模型，他由一个Master进程和多个Worker进程组成。Master在初始化时会建立一个socket，但是不会接受和处理请求，而是由fork出来的子进程完成这些工作。<br>
Master进程和Woker进程之间不会直接通信，而是通过共享内存Master知道Woker进程的信息</p>
<h4 id="master-进程">master 进程</h4>
<p>从代码中可以看到 master在调用fpm_run()后不再返回，而是进入fpm_event_loop(),这个方法会循环处理注册的几个I/O事件。</p>
<h4 id="multi-worker-进程">multi worker 进程</h4>
<p>woker的工作就是 争抢处理请求，争抢成功后，解析FastCGI协议，获得服务器真实的php脚本地址，然后编译执行脚本，但是woker进程是阻塞的，这样是为了简单粗暴的解决进程资源安全问题。<br>
下面是woker执行的几个阶段:</p>
<ul>
<li>
<p>等待请求：woker进程阻塞在 fcgi_accept_request()中等待请求。</p>
</li>
<li>
<p>解析请求:   fastcgi请求到达后被，woker开始接受，然后解析请求，request数据陆续到达，直到request完整开始执行编译。</p>
</li>
<li>
<p>ZEND_VM初始化： 执行php_request_startup(), <code>此阶段会调用每个扩展的PHP_RINT_FUNCTTION()</code>,并且激活GC模块等等。</p>
</li>
<li>
<p>执行脚本：   由php_execute_script() 激活zend_vm ，编译执行j脚本。(不清楚 可以gdb attache fpm 一下 然后打个断点)</p>
</li>
<li>
<p>收尾:  由php_request_shutdown()完成，并且调用每个扩展的PHP_RSHUTDOWN_FUNCTION()。</p>
</li>
</ul>
<h2 id="php-fpm-配置与优化">PHP-FPM 配置与优化</h2>
<ul>
<li>不讲apache与php-fpm 我用的不多，没有深入了解过。</li>
</ul>
<h3 id="几个关键的配置">几个关键的配置</h3>
<p>fpm一般有两个配置文件，fpm.conf 是针对所有的，www.conf 是针对fpm  master-woker pool的</p>
<ul>
<li>
<p>fpm.conf</p>
</li>
<li>
<p>error_log = log/php-fpm.log   <code>错误日志：超时，woker不够用，php 脚本crash都会记录在这里</code></p>
</li>
<li>
<p>process.max = 128 <code>控制全局的woker数量</code></p>
</li>
<li>
<p>www.conf</p>
<ul>
<li>listen = 127.0.0.1:9000 <code>fpm FastCGI 端口，与常用的http服务做通讯(nginx, apache, iis)</code></li>
<li>listen.allowed_clients = 127.0.0.1 <code>允许访问的客户端，如果这个是127.0.0.1则 nginx或者apache 需要与php-fpm在一台主机上</code></li>
</ul>
<ul>
<li>下面的上文讲过</li>
</ul>
<ul>
<li>pm = dynamic</li>
<li>pm.max_children = 5</li>
<li>pm.start_servers = 2</li>
<li>pm.min_spare_servers = 1</li>
<li>pm.max_spare_servers = 3</li>
<li>pm.process_idle_timeout = 10s;</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>