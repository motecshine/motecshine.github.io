<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>深入浅出Rust Future - Part 2 | Gridea</title>
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico?v=1581187173473">
<link href="https://cdn.remixicon.com/releases/v2.1.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="http://localhost:4000/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="深入浅出Rust Future - Part 2 | Gridea - Atom Feed" href="http://localhost:4000/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="译自Rust futures: an uneducated, short and hopefully not boring tutorial - Part 2
Intro
在这个系列的第一篇文章我们了解了如何使用Rust Future.但是..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://localhost:4000">
  <img class="avatar" src="http://localhost:4000/images/avatar.png?v=1581187173473" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="http://localhost:4000/" class="menu">
          首页
        </a>
      
    
      
        <a href="http://localhost:4000/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="http://localhost:4000/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="http://localhost:4000/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              深入浅出Rust Future - Part 2
            </h2>
            <div class="post-info">
              <span>
                2020-02-09
              </span>
              <span>
                10 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>译自<a href="https://dev.to/mindflavor/rust-futures-an-uneducated-short-and-hopefully-not-boring-tutorial---part-2-8dd">Rust futures: an uneducated, short and hopefully not boring tutorial - Part 2</a></p>
<h1 id="intro">Intro</h1>
<p>在这个系列的第一篇文章我们了解了如何使用<code>Rust Future</code>.但是只有我们彻底的了解<code>Future</code>并且操作得当才能发挥它真正的作用。这个系列的第二篇文章，我们将介绍如何避免<code>Future</code>里常见的陷阱。</p>
<!-- more -->
<h2 id="error-troubles">Error troubles</h2>
<p>我们将<code>Future</code>组织成一个<code>链</code>很简单，只要通过<code>Rust Future</code>提供的<code>and_then</code>函数就可以了。但是在上一篇文章中我们使用了<code>Box&lt;Error&gt; trait</code>作为错误类型，绕过了编译器的检查。为什么我们没有使用更为详细的错误类型？原因很简单， 每个<code>Future</code>函数的错误返回都有可能不同.</p>
<blockquote>
<p>原则1: 当我们将不同的<code>Future</code>组织成一个调用<code>链</code>时，每个<code>Future</code>都应该返回相同的<code>Error Type</code>.</p>
</blockquote>
<p>让我们一起来证明一下这一点.</p>
<p>我们有两个被叫做<code>ErrorA</code>和<code>ErrorB</code>的<code>Error</code>类型,  我们将会实现<code>error::Error trait</code>,尽管这并不是编译器必须让我们做的(但是这是一个好习惯[在我看来这应该算是一个最佳实践]),在我们实现<code>error::Error trait</code>的同时还需要实现<code>std::fmt::Display</code>,现在就让我们一起实现他吧!</p>
<pre><code>#[derive(Debug, Default)]
pub struct ErrorA {}

impl fmt::Display for ErrorA {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;ErrorA!&quot;)
    }
}

impl error::Error for ErrorA {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;Description for ErrorA&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        None
    }
}

// Error B
#[derive(Debug, Default)]
pub struct ErrorB {}

impl fmt::Display for ErrorB {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;ErrorB!&quot;)
    }
}

impl error::Error for ErrorB {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;Description for ErrorB&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        None
    }
}
</code></pre>
<p>我尽量用简单的方式去实现<code>Error Trait</code>,这样可以排除别的干扰来证明我的观点. 现在让我们在<code>Future</code>中使用<code>ErrorA</code>与<code>ErrorB</code>.</p>
<pre><code>fn fut_error_a() -&gt; impl Future&lt;Item = (), Error = ErrorA&gt; {
    err(ErrorA {})
}

fn fut_error_b() -&gt; impl Future&lt;Item = (), Error = ErrorB&gt; {
    err(ErrorB {})
}
</code></pre>
<p>现在让我们在<code>main</code>函数里调用它.</p>
<pre><code>let retval = reactor.run(fut_error_a()).unwrap_err();
println!(&quot;fut_error_a == {:?}&quot;, retval);

let retval = reactor.run(fut_error_b()).unwrap_err();
println!(&quot;fut_error_b == {:?}&quot;, retval);
</code></pre>
<p>跟我们所预见的结果一致:</p>
<pre><code>fut_error_a == ErrorA
fut_error_b == ErrorB
</code></pre>
<p>到现在为止还挺好的，让我们把<code>ErrorA</code>与<code>ErrorB</code>打包成一个调用链:</p>
<pre><code>let future = fut_error_a().and_then(|_| fut_error_b());
</code></pre>
<p>我们先调用<code>fut_error_a</code>然后再调用<code>fut_error_b</code>,我们不用关心<code>fut_error_a</code>的返回值所以我们用<code>_</code>省略不用. 用更复杂的术语解释就是: 我们将<code>impl Future&lt;Item=(), Error=ErrorA&gt;</code> 和 <code>impl Future&lt;Item=(), Error=ErrorB&gt;</code>打包成调用链.</p>
<p>现在让我们尝试编译这段代码:</p>
<pre><code>
Compiling tst_fut2 v0.1.0 (file:///home/MINDFLAVOR/mindflavor/src/rust/tst_future_2)
error[E0271]: type mismatch resolving `&lt;impl futures::Future as futures::IntoFuture&gt;::Error == errors::ErrorA`
   --&gt; src/main.rs:166:32
    |
166 |     let future = fut_error_a().and_then(|_| fut_error_b());
    |                                ^^^^^^^^ expected struct `errors::ErrorB`, found struct `errors::ErrorA`
    |
    = note: expected type `errors::ErrorB`
               found type `errors::ErrorA`
</code></pre>
<p>这个报错非常明显, 编译器期待我们使用<code>ErrorB</code>但是我们给了一个<code>ErrorA</code>。</p>
<blockquote>
<p>原则2: 当我们组织<code>Future Chain</code>时，第一个错误类型必须与最后一个<code>future</code>返回的错误类型一致.(When chaining futures, the first function error type must be the same as the chained one.)</p>
</blockquote>
<p><code>rustc</code>已经非常明确的告诉我们了. 这个<code>Future chain</code>最终返回的是<code>ErrorB</code>所以我们第一个函数也应该返回<code>ErrorB</code>. 在上述代码我们返回了<code>ErrorA</code>, 所以导致编译失败.</p>
<p>我们改如何处理这个问题?非常幸运的是, 我们可以使用<code>Rust Future</code>给我们提供的<code>map_err</code>方法. 在我们的示例中，我们想要把<code>ErrorA</code>转换成<code>ErrorB</code>,所以我们只需要在<code>ErrorA</code>与<code>ErrorB</code>之间调用这个函数就行了.</p>
<pre><code>let future = fut_error_a()
    .map_err(|e| {
        println!(&quot;mapping {:?} into ErrorB&quot;, e);
        ErrorB::default()
    })
    .and_then(|_| fut_error_b());

let retval = reactor.run(future).unwrap_err();
println!(&quot;error chain == {:?}&quot;, retval);
</code></pre>
<p>如果我们现在编译并运行示例，将会输出：</p>
<pre><code>mapping ErrorA into ErrorB
error chain == ErrorB
</code></pre>
<p>让我们进一步推动这个例子.假设我们想连接ErrorA，然后是ErrorB，然后再连接ErrorA。 就像是：</p>
<pre><code>let future = fut_error_a()
    .and_then(|_| fut_error_b())
    .and_then(|_| fut_error_a());
</code></pre>
<p>我们最初的解决方式只适合成对的<code>future</code>， 并没有考虑其他的情况。所以在上面代码中我们不得不这么做:<br>
<code>ErrorA =&gt; ErrorB =&gt; ErrorA</code>.就像这样:</p>
<pre><code>let future = fut_error_a()
    .map_err(|_| ErrorB::default())
    .and_then(|_| fut_error_b())
    .map_err(|_| ErrorA::default())
    .and_then(|_| fut_error_a());
</code></pre>
<p>看上去不那么优雅但是还是解决了多个<code>Future</code>的错误处理.</p>
<h2 id="from-to-the-rescue">&quot;From&quot; to the rescue</h2>
<p>简化上述代码的一种简单的方式就是利用<code>std::covert::From</code>. 当我们实现<code>From</code>, 这样编译器就可以自动的将一个结构软换为另一个结构.现在让我们实现<code>From&lt;ErrorA&gt; for ErrorB</code>和<code>From&lt;ErrorB&gt; for ErrorA</code>.</p>
<pre><code>impl From&lt;ErrorB&gt; for ErrorA {
    fn from(e: ErrorB) -&gt; ErrorA {
        ErrorA::default()
    }
}

impl From&lt;ErrorA&gt; for ErrorB {
    fn from(e: ErrorA) -&gt; ErrorB {
        ErrorB::default()
    }
}
</code></pre>
<p>通过上述的实现我们只需要用<code>from_err</code>函数来代替<code>map_err</code>就好了。</p>
<pre><code>let future = fut_error_a()
   .from_err()
   .and_then(|_| fut_error_b())
   .from_err()
   .and_then(|_| fut_error_a());
</code></pre>
<p>现在的代码仍然与错误转换混合, 但转换代码不再是内联的，而且代码可读性也提高了。<code>Futrue Crate</code>非常聪明:只有在错误的情况下才会调用<code>from_err</code>代码， 因此在不使用<code>from_err</code>时, 也不会在<code>Runtime</code>时产生额外的开销.</p>
<h2 id="lifetimes">Lifetimes</h2>
<p>Rust签名功能是引用的显式生命周期注释. 但是，大多数情况下，Rust允许我们避免使用生命周期省略来指定生命周期.让我们看看它的实际效果. 我们想编写一个带字符串引用的函数，如果成功则返回相同的字符串引用：</p>
<pre><code>fn my_fn_ref&lt;'a&gt;(s: &amp;'a str) -&gt; Result&lt;&amp;'a str, Box&lt;Error&gt;&gt; {
    Ok(s)
}
</code></pre>
<p>注意代码中 <code>&lt;'a&gt;</code> 的部分, 意思是我们显示的声明一个<code>生命周期</code>. 接着我们声明了一个引用形参<code>s: &amp;'a str</code>, 这个参数必须在<code>'a</code>生命周期有效的情况下使用.使用<code>Result &lt;＆'str，Box &lt;Error &gt;&gt;</code>，我们告诉<code>Rust</code>我们的返回值将包含一个字符串引用.只要'a有效，该字符串引用必须有效.换句话说，传递的字符串引用和返回的对象必须具有相同的生命周期.这会导致我们的语法非常冗长，以至于Rust允许我们避免在常见情况下指定生命周期。 所以我们可以这样重写函数：</p>
<pre><code>fn my_fn_ref(s: &amp;str) -&gt; Result&lt;&amp;str, Box&lt;Error&gt;&gt; {
    Ok(s)
}
</code></pre>
<p>但是在<code>Future</code>中你不能这样写， 让我们来尝试用<code>Future</code>方式复写这个函数:</p>
<pre><code>fn my_fut_ref_implicit(s: &amp;str) -&gt; impl Future&lt;Item = &amp;str, Error = Box&lt;Error&gt;&gt; {
    ok(s)
}
</code></pre>
<p>编译将会失败(<code>rustc 1.23.0-nightly (2be4cc040 2017-11-01</code>)：</p>
<pre><code>Compiling tst_fut2 v0.1.0 (file:///home/MINDFLAVOR/mindflavor/src/rust/tst_future_2)
error: internal compiler error: /checkout/src/librustc_typeck/check/mod.rs:633: escaping regions in predicate Obligation(predicate=Binder(ProjectionPredicate(ProjectionTy { substs: Slice([_]), item_def_id: DefId { krate: CrateNum(15), index: DefIndex(0:330) =&gt; futures[59aa]::future[0]::Future[0]::Item[0] } }, &amp;str)),depth=0)
  --&gt; src/main.rs:39:36
   |
39 | fn my_fut_ref_implicit(s: &amp;str) -&gt; impl Future&lt;Item = &amp;str, Error = Box&lt;Error&gt;&gt; {
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

note: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports

note: rustc 1.23.0-nightly (2be4cc040 2017-11-01) running on x86_64-unknown-linux-gnu

thread 'rustc' panicked at 'Box&lt;Any&gt;', /checkout/src/librustc_errors/lib.rs:450:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>当然也有解决方式，我们只要显示声明一个有效的生命周期就行了:</p>
<pre><code>fn my_fut_ref&lt;'a&gt;(s: &amp;'a str) -&gt; impl Future&lt;Item = &amp;'a str, Error = Box&lt;Error&gt;&gt; {
    ok(s)
}
</code></pre>
<h2 id="impl-future-with-lifetimes">impl Future with lifetimes</h2>
<p>在<code>Future</code>中如果有引用传参我们必须要显示的注释生命周期. 举个例子, 我们希望使用<code>&amp;s</code>的值并且返回的是一个没有引用的<code>String</code>.我们必须显示的注释生命周期:</p>
<pre><code>fn my_fut_ref_chained&lt;'a&gt;(s: &amp;'a str) -&gt; impl Future&lt;Item = String, Error = Box&lt;Error&gt;&gt; {
    my_fut_ref(s).and_then(|s| ok(format!(&quot;received == {}&quot;, s)))
}
</code></pre>
<p>上面的代码将会报错:</p>
<pre><code>error[E0564]: only named lifetimes are allowed in `impl Trait`, but `` was found in the type `futures::AndThen&lt;impl futures::Future, futures::FutureResult&lt;std::string::String, std::boxed::Box&lt;std::error::Error + 'static&gt;&gt;, [closure@src/main.rs:44:28: 44:64]&gt;`
  --&gt; src/main.rs:43:42
   |
43 | fn my_fut_ref_chained&lt;'a&gt;(s: &amp;'a str) -&gt; impl Future&lt;Item = String, Error = Box&lt;Error&gt;&gt; {
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>为了解决这个错误我们必须为<code>impl Future</code>追加一个<code>'a</code>生命周期：</p>
<pre><code>fn my_fut_ref_chained&lt;'a&gt;(s: &amp;'a str) -&gt; impl Future&lt;Item = String, Error = Box&lt;Error&gt;&gt; + 'a {
    my_fut_ref(s).and_then(|s| ok(format!(&quot;received == {}&quot;, s)))
}
</code></pre>
<p>现在你可以运行这段代码了:</p>
<pre><code>let retval = reactor
    .run(my_fut_ref_chained(&quot;str with lifetime&quot;))
    .unwrap();
println!(&quot;my_fut_ref_chained == {}&quot;, retval);
</code></pre>
<h2 id="closing-remarks">Closing remarks</h2>
<p>在下一篇文章中，我们将介绍<code>Reactor</code>。 我们还将从头开始编写未来的实现结构。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#intro">Intro</a>
<ul>
<li><a href="#error-troubles">Error troubles</a></li>
<li><a href="#from-to-the-rescue">&quot;From&quot; to the rescue</a></li>
<li><a href="#lifetimes">Lifetimes</a></li>
<li><a href="#impl-future-with-lifetimes">impl Future with lifetimes</a></li>
<li><a href="#closing-remarks">Closing remarks</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://localhost:4000/post/shen-ru-qian-chu-rust-future-part-1">
              <h3 class="post-title">
                深入浅出Rust Future - Part 1
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="http://localhost:4000/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
